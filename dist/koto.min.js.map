{"version":3,"file":"koto.js","sources":["koto.js","/source/koto.js"],"names":["global","factory","exports","module","require","define","amd","koto","d3","this","kotoAssert","test","message","Error","assert","Layer","base","options","_base","_handlers","_lifecycleRe","dataBind","insert","eventName","events","on","data","handler","push","callback","chart","idx","handlers","arguments","length","splice","bound","entering","selection","method","len","tidx","tlen","call","enter","_chart","name","exit","i","l","empty","transition","__layer","Chart","baseExtend","dst","maps","setDst","value","key","set","ii","map","forEach","hasDrawn","merge","configs","args","Array","_len","_key","merged","bind","accessors","_len2","_key2","Map","_layers","_attached","_events","layer","_layer","_Chart","get","remove","attachmentName","rawData","attachmentData","transform","preDraw","_step","_iterator","values","Symbol","iterator","_iteratorNormalCompletion","next","done","draw","_step2","_iterator2","entries","_iteratorNormalCompletion2","_step2$value","attachment","demux","postDraw","context","has","Set","add","self","_once","off","apply","clear","event","clone","_len3","_key3","_event$callback","concat","nameOrObject","setPercentage","calcultePerecentage","arr","initialValue","min","Math","config","definition","constrain","percentage","isArray","hasOwnProperty","setter","console","warn","getter","item","init","Extended","_ref","_get","Object","getPrototypeOf","prototype","initialize","Base","index"],"mappings":"gyCCAC,SAAUA,EAAQC,GACI,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,EAAQG,QAAQ,OAC9E,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,MAAOJ,GAC5DD,EAAOO,KAAON,EAAQD,EAAOQ,KAC/BC,KAAM,SAAUD,GAAM,YAQpB,SAASE,GAAWC,EAAMC,GACtB,IAAID,EAGJ,KAAM,IAAIE,OAAK,UAAWD,GAE9B,GAAIE,GAASJ,EAGPK,EAAK,WACI,QADTA,GACUC,EAAMC,GAId,wBALFF,GAEEN,KAAKS,MAAQF,EACbP,KAAKU,aACLV,KAAKW,aAAe,4CAChBH,IAEAR,KAAKY,SAAWJ,EAAQI,SACxBZ,KAAKa,OAASL,EAAQK,OAElB,UAAYL,IACZ,IAAK,GAAIM,KAAaN,GAAQO,OAC1Bf,KAAKgB,GAAGF,EAAWN,EAAQO,OAAOD,wBAZhDR,yBAuBM,SAACW,GACLZ,GAAO,EAAO,gEAOZ,WACFA,GAAO,EAAO,6DAahB,SAACS,EAAWI,EAASV,GAUnB,MATAA,GAAUA,MACVH,EAAOL,KAAKW,aAAaT,KAAKY,GAAU,+DAAiEA,EAAS,MAC5GA,IAAad,MAAKU,YACpBV,KAAKU,UAAUI,OAEnBd,KAAKU,UAAUI,GAAWK,MACtBC,SAAUF,EACVG,MAAOb,EAAQa,OAAS,OAErBrB,wBAYR,SAACc,EAAWI,GACX,GACII,GADAC,EAAWvB,KAAKU,UAAUI,EAG9B,IADAT,EAAOL,KAAKW,aAAaT,KAAKY,GAAU,+DAAiEA,EAAS,OAC7GS,EACD,MAAOvB,KAEX,IAAyB,IAArBwB,UAAUC,OAEV,MADAF,GAASE,OAAS,EACXzB,IAEX,KAAKsB,EAAMC,EAASE,OAAS,EAAGH,EAAM,KAAMA,EACpCC,EAASD,GAAKF,WAAaF,GAC3BK,EAASG,OAAOJ,EAAK,EAG7B,OAAOtB,0BAiBP,SAACiB,GACD,GAAIU,GAAOC,EAAUb,EAAQc,EAAWC,EAAQP,EAAUT,EAAWQ,EAAKS,EAAKC,EAAMC,CACrFN,GAAQ3B,KAAKY,SAASsB,KAAKlC,KAAKS,MAAOQ,GACvCZ,EAAOsB,YAAiB5B,GAAG8B,UAAW,yDACtCxB,EAAOsB,EAAMQ,MAAO,uCACpBP,EAAWD,EAAMQ,QACjBP,EAASQ,OAASpC,KAAKS,MAAM2B,OAC7BrB,IAEQsB,KAAM,SACNR,UAAWF,IAGXU,KAAM,QACNR,UAAWD,EACXE,OAAQ9B,KAAKa,SAGbwB,KAAM,QAKNR,UAAWF,IAGXU,KAAM,OAKNR,UAAWF,EACXG,OAAQH,EAAMW,MAGtB,KAAK,GAAIC,GAAI,EAAGC,EAAIzB,EAAOU,OAAYe,EAAJD,IAASA,EASxC,GARAzB,EAAYC,EAAOwB,GAAGF,KACtBR,EAAYd,EAAOwB,GAAGV,UACtBC,EAASf,EAAOwB,GAAGT,OAGG,kBAAXA,KACPD,EAAYC,EAAOI,KAAKL,KAExBA,EAAUY,QAAd,CAQA,GAFApC,EAAOwB,GAAaA,YAAqB9B,GAAG8B,UAAS,iCAAmCf,EAAS,qBACjGS,EAAWvB,KAAKU,UAAUI,GAEtB,IAAKQ,EAAM,EAAGS,EAAMR,EAASE,OAAcM,EAANT,IAAaA,EAG9CO,EAAUO,OAASb,EAASD,GAAKD,OAASrB,KAAKS,MAAM2B,OACrDP,EAAUK,KAAKX,EAASD,GAAKF,SAIrC,IADAG,EAAWvB,KAAKU,UAAUI,EAAY,eAClCS,GAAYA,EAASE,OAErB,IADAI,EAAYA,EAAUa,aACjBT,EAAOV,EAASE,OAAQO,EAAO,EAAUC,EAAPD,IAAeA,EAClDH,EAAUO,OAASb,EAASS,GAAMX,OAASrB,KAAKS,MAAM2B,OACtDP,EAAUK,KAAKX,EAASS,GAAMZ,eArK5Cd,KA2KFqC,EAAUrC,EAGRsC,EAAK,WACI,QADTA,GACUf,GAGR,QAASgB,GAAWC,EAAKC,GAIrB,IAAK,GAHDC,GAAS,SAAUC,EAAOC,GAC1BJ,EAAIK,IAAID,EAAKD,IAERV,EAAI,EAAGa,EAAKL,EAAKtB,OAAY2B,EAAJb,IAAUA,EAAG,CAC3C,GAAIc,GAAMN,EAAKR,EACfc,GAAIC,QAAQN,GAEhB,MAAOF,wBAZbF,GAEE5C,KAAKO,KAAOsB,EACZ7B,KAAKuD,UAAW,EAWhBvD,KAAKwD,OACDC,QAAS,sCAAaC,EAAIC,MAAAC,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAJH,EAAIG,GAAArC,UAAAqC,EACtB,IAAIC,GAASjB,EAAW7C,KAAKyD,QAASC,EACtC,OAAOI,IACTC,KAAK/D,MACPgE,UAAW,sCAAaN,EAAIC,MAAAM,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAJR,EAAIQ,GAAA1C,UAAA0C,EACxB,IAAIJ,GAASjB,EAAW7C,KAAKgE,UAAWN,EACxC,OAAOI,IACTC,KAAK/D,OAGXA,KAAKyD,QAAU,GAAIU,KACnBnE,KAAKgE,UAAY,GAAIG,KAErBnE,KAAKoE,QAAU,GAAID,KACnBnE,KAAKqE,UAAY,GAAIF,KACrBnE,KAAKsE,QAAU,GAAIH,yBA9BrBvB,0BA6CO,SAAC3B,GAAQ,MAAOA,wBAgBpB,SAACoB,EAAMpB,GAAQ,MAAOA,0BAYpB,SAACA,4BAYA,SAACA,2BAOF,SAACoB,GACJ,GAAIkC,GAAQvE,KAAKuE,MAAMlC,EAGvB,OAFArC,MAAKoE,QAAO,UAAQ/B,SACbkC,GAAMnC,OACNmC,uBA2BN,SAAClC,EAAMR,EAAWrB,GACnB,GACIgE,GADAC,EAASzE,IAEb,IAAyB,IAArBwB,UAAUC,OACV,MAAOzB,MAAKoE,QAAQM,IAAIrC,EAI5B,IAAyB,IAArBb,UAAUC,OAAc,CACxB,GAAII,EAAUO,OAGV,MAFAP,GAAUO,OAASpC,KACnBA,KAAKoE,QAAQjB,IAAId,EAAMR,GAChB7B,KAAKoE,QAAQM,IAAIrC,EAGxBhC,IAAO,EAAO,0EAWtB,MAPAmE,GAAS,GAAI7B,GAAQd,EAAWrB,GAChCR,KAAKoE,QAAQjB,IAAId,EAAMmC,GACvB3C,EAAUO,OAASpC,KACnBwE,EAAOG,OAAS,WAEZ,MADAF,GAAOL,QAAO,UAAQ/B,GACfrC,MAEJwE,wBAcL,SAACI,EAAgBvD,GACnB,MAAyB,KAArBG,UAAUC,OACHzB,KAAKqE,UAAUK,IAAIE,IAE9B5E,KAAKqE,UAAUlB,IAAIyB,EAAgBvD,GAC5BA,uBAcP,SAACwD,GACD,GAAIN,GAAOO,EACP7D,EAAOjB,KAAK+E,UAAUF,EAC1B7E,MAAKgF,QAAQ/D,8BACb,IAAA,GAAmCgE,GAAnCC,EAAclF,KAAKoE,QAAQe,SAAQC,OAAAC,cAAAC,GAAAL,EAAAC,EAAAK,QAAAC,MAAAF,GAAA,EAA9Bf,EAAKU,EAAAhC,MACNsB,EAAMkB,KAAKxE,iHAEf,IAAA,GAAiEyE,GAAjEC,EAAyC3F,KAAKqE,UAAUuB,UAASR,OAAAC,cAAAQ,GAAAH,EAAAC,EAAAJ,QAAAC,MAAAK,GAAA,EAAE,iCAAzDjB,EAAckB,EAAA,GAAEC,EAAUD,EAAA,EAChChB,GAAiB9E,KAAKgG,MAAQhG,KAAKgG,MAAMpB,EAAgB3D,GAAQA,EACjE8E,EAAWN,KAAKX,uFAEpB9E,KAAKuD,UAAW,EAChBvD,KAAKiG,SAAShF,qBAwBhB,SAACoB,EAAMjB,EAAU8E,GACf,GAAInF,EAaJ,OAXIA,GADAf,KAAKsE,QAAQ6B,IAAI9D,GACRrC,KAAKsE,QAAQI,IAAIrC,GAGjB,GAAI+D,KAEjBrF,EAAOsF,KACHjF,SAAUA,EACV8E,QAASA,GAAWlG,KACpBoC,OAAQpC,OAEZA,KAAKsE,QAAQnB,IAAId,EAAMtB,GAChBf,yBAkBP,SAACqC,EAAMjB,EAAU8E,GACjB,GAAII,GAAOtG,KACPuG,EAAQ,QAARA,KACAD,EAAKE,IAAInE,EAAMkE,GACfnF,EAASqF,MAAMzG,KAAMwB,WAEzB,OAAOxB,MAAKgB,GAAGqB,EAAMkE,EAAOL,sBAmB7B,SAAC7D,EAAMjB,EAAU8E,GAEhB,MAAyB,KAArB1E,UAAUC,QACVzB,KAAKsE,QAAQoC,QACN1G,MAGc,IAArBwB,UAAUC,QACNzB,KAAKsE,QAAQ6B,IAAI9D,IACjBrC,KAAKsE,QAAQI,IAAIrC,GAAMqE,QAEpB1G,OAIXA,KAAKsE,QAAQI,IAAIrC,GAAMiB,QAAQ,SAACqD,EAAOC,EAAOvD,IACtCjC,GAAaA,IAAawF,EAAMxF,UAC/B8E,GAAWA,IAAYU,EAAMV,UAC9B7C,EAAG,UAAQsD,KAGZ3G,6BAaJ,SAACqC,8BAASqB,EAAIC,MAAAkD,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAJpD,EAAIoD,EAAA,GAAAtF,UAAAsF,EAMjB,OALI9G,MAAKsE,QAAQ6B,IAAI9D,IACjBrC,KAAKsE,QAAQI,IAAIrC,GAAMiB,QAAQ,SAACqD,UAC5BI,EAAAJ,EAAMvF,UAASc,KAAIuE,MAAAM,GAACJ,EAAMT,SAAOc,OAAKtD,MAGvC1D,2BAUL,SAACiH,EAAchE,GAIjB,QAASiE,KACL,QAASC,GAAoBC,EAAKC,GAC9B,GAAIC,GAAMC,KAAKD,IAAIpF,KAAK,KAAMkF,EAAI/D,IAAI,SAAUhB,GAAQ,MAAOoC,GAAO+C,OAAOnF,KAC7E,OAAOgF,GAAeC,EAEtBG,EAAWC,aAAc,EACzBD,EAAWE,WAAaR,GAAqB,QAAS,UAAWM,EAAWxE,OAEvEU,MAAMiE,QAAQH,EAAWC,WAC9BD,EAAWE,WAAaR,EAAoBM,EAAWC,UAAWD,EAAWxE,OAG7EwE,EAAWE,WAAaR,GAAqBM,EAAWC,WAAYD,EAAWxE,OAfvF,GAAIC,GACAuE,EACAhD,EAASzE,IAgBb,IAAyB,IAArBwB,UAAUC,OACV,MAAOzB,MAAKyD,OAEhB,IAAyB,IAArBjC,UAAUC,OAAc,CACxB,GAA4B,gBAAjBwF,GAA2B,CAClC,IAAK/D,IAAO+D,GACJjH,KAAKyD,QAAQ0C,IAAIjD,IACjBuE,EAAazH,KAAKyD,QAAQiB,IAAIxB,GAC1BuE,EAAWI,eAAe,UAC1BJ,EAAWxE,MAAQwE,EAAWK,OAAO5F,KAAKuF,EAAYR,EAAa/D,IAGnEuE,EAAWxE,MAAQgE,EAAa/D,GAEhCuE,EAAWI,eAAe,cAC1BX,IAEJlH,KAAKyD,QAAQN,IAAID,EAAKuE,IAGtBM,QAAQC,KAAI,oBAAqBf,EAAY,mBAGrD,OAAOjH,MAIX,MAFAK,GAAOL,KAAKyD,QAAQ0C,IAAIc,GAAa,GAAKA,EAAY,2BACtDQ,EAAazH,KAAKyD,QAAQiB,IAAIuC,GAC1BQ,EAAWI,eAAe,UACnBJ,EAAWQ,OAAO/F,KAAKuF,GAE3BA,EAAWxE,MAEtB,MAAyB,KAArBzB,UAAUC,QACNzB,KAAKyD,QAAQ0C,IAAIc,IACjBQ,EAAazH,KAAKyD,QAAQiB,IAAIuC,GAC1BQ,EAAWI,eAAe,UAC1BJ,EAAWxE,MAAQwE,EAAWK,OAAO5F,KAAKuF,EAAYxE,GAGtDwE,EAAWxE,MAAQA,EAEnBwE,EAAWI,eAAe,cAC1BX,IAEJlH,KAAKyD,QAAQN,IAAI8D,EAAcQ,IAG/BM,QAAQC,KAAI,oBAAqBf,EAAY,oBAE1CjH,MAjBX,+BA4BI,SAACkI,EAAMjF,GACX,GAAIC,EACJ,IAAyB,IAArB1B,UAAUC,OACV,MAAOzB,MAAKgE,SAEhB,IAAyB,IAArBxC,UAAUC,OAAc,CACxB,GAAoB,gBAATyG,GAEP,MADA7H,GAAOL,KAAKgE,UAAUmC,IAAI+B,GAAK,GAAKA,EAAI,6BACjClI,KAAKgE,UAAUU,IAAIwD,EAG1B,KAAKhF,IAAOgF,GACRlI,KAAKgE,UAAUb,IAAID,EAAKgF,EAAKhF,QAKrClD,MAAKgE,UAAUb,IAAI+E,EAAMjF,EAE7B,OAAOjD,8BAOE,SAACmI,MACJC,GAAQ,SAAAC,GACC,QADTD,GACUvG,wBADVuG,EAEE,IAAIlF,EAEJ,IADAoF,KAAAC,OAAAC,eAHFJ,EAAQK,WAAA,cAAAzI,MAAAkC,KAAAlC,KAGA6B,GACc,kBAATsG,GACPA,EAAKjG,KAAKlC,UAET,CACD,IAAKkD,IAAOiF,GACRnI,KAAKkD,GAAOiF,EAAKjF,EAErBiF,GAAKO,WAAWxG,KAAKlC,wBAX3BoI,EAAQC,GAARD,GAAiBpI,KAevB,OAAOoI,OA9bTxF,KAicFR,EAASQ,CAGbvC,GAAON,EAAI,qBACX,IAAID,KACJA,GAAK6I,KAAOvG,CACZ,IAAIwG,GAAQ9I,CAEZ,OAAO8I;;;;;;;;;;;;AD5oBX,AAAC,CAAA,UAAU,MAAM,EAAE,OAAO,EAAE;AACxB,WAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,WAAW,GAAG,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,GACtG,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,GACpE,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;CACnC,CAAA,CAAC,IAAI,EAAE,UAAU,EAAE,EAAE;AAAE,gBAAY,CAAC;;;;;;;;AAQjC,aAAS,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE;AAC/B,YAAI,IAAI,EAAE;AACN,mBAAO;SACV;AACD,cAAM,IAAI,KAAK,aAAW,OAAO,CAAG,CAAC;KACxC;AACD,QAAI,MAAM,GAAG,UAAU,CAAC;;;;QAGlB,KAAK;AACI,iBADT,KAAK,CACK,IAAI,EAAE,OAAO,EAAE;kCADzB,KAAK;;AAEH,gBAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,gBAAI,CAAC,SAAS,GAAG,EAAE,CAAC;AACpB,gBAAI,CAAC,YAAY,GAAG,2CAA2C,CAAC;AAChE,gBAAI,OAAO,EAAE;;AAET,oBAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;AACjC,oBAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;;AAE7B,oBAAI,QAAQ,IAAI,OAAO,EAAE;AACrB,yBAAK,IAAI,SAAS,IAAI,OAAO,CAAC,MAAM,EAAE;AAClC,4BAAI,CAAC,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;qBACjD;iBACJ;aACJ;SACJ;;qBAhBC,KAAK;;;;;;;;;mBAuBC,kBAAC,IAAI,EAAE;AACX,sBAAM,CAAC,KAAK,EAAE,wCAAwC,CAAC,CAAC;aAC3D;;;;;;;;;mBAMK,kBAAG;AACL,sBAAM,CAAC,KAAK,EAAE,yCAAyC,CAAC,CAAC;aAC5D;;;;;;;;;;;;;;;mBAYC,YAAC,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE;AAC5B,uBAAO,GAAG,OAAO,IAAI,EAAE,CAAC;AACxB,sBAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,sEAAiE,SAAS,SAAK,CAAC;AACxH,oBAAI,EAAE,SAAS,IAAI,IAAI,CAAC,SAAS,CAAA,AAAC,EAAE;AAChC,wBAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;iBAClC;AACD,oBAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC;AAC3B,4BAAQ,EAAE,OAAO;AACjB,yBAAK,EAAE,OAAO,CAAC,KAAK,IAAI,IAAI;iBAC/B,CAAC,CAAC;AACH,uBAAO,IAAI,CAAC;aACf;;;;;;;;;;;;;;mBAWE,aAAC,SAAS,EAAE,OAAO,EAAE;AACpB,oBAAI,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;AACzC,oBAAI,GAAG,CAAC;AACR,sBAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,sEAAiE,SAAS,SAAK,CAAC;AACxH,oBAAI,CAAC,QAAQ,EAAE;AACX,2BAAO,IAAI,CAAC;iBACf;AACD,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,4BAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;AACpB,2BAAO,IAAI,CAAC;iBACf;AACD,qBAAK,GAAG,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE;AAC7C,wBAAI,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,KAAK,OAAO,EAAE;AACpC,gCAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;qBAC3B;iBACJ;AACD,uBAAO,IAAI,CAAC;aACf;;;;;;;;;;;;;;;;;;;mBAgBG,cAAC,IAAI,EAAE;AACP,oBAAI,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC;AAC1F,qBAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC7C,sBAAM,CAAC,KAAK,YAAY,EAAE,CAAC,SAAS,EAAE,uDAAuD,CAAC,CAAC;AAC/F,sBAAM,CAAC,KAAK,CAAC,KAAK,EAAE,qCAAqC,CAAC,CAAC;AAC3D,wBAAQ,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;AACzB,wBAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACpC,sBAAM,GAAG,CACL;AACI,wBAAI,EAAE,QAAQ;AACd,6BAAS,EAAE,KAAK;iBACnB,EACD;AACI,wBAAI,EAAE,OAAO;AACb,6BAAS,EAAE,QAAQ;AACnB,0BAAM,EAAE,IAAI,CAAC,MAAM;iBACtB,EACD;AACI,wBAAI,EAAE,OAAO;;;;;AAKb,6BAAS,EAAE,KAAK;iBACnB,EACD;AACI,wBAAI,EAAE,MAAM;;;;;AAKZ,6BAAS,EAAE,KAAK;AAChB,0BAAM,EAAE,KAAK,CAAC,IAAI;iBACrB,CACJ,CAAC;AACF,qBAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;AAC3C,6BAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AAC3B,6BAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AAChC,0BAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;;;AAG1B,wBAAI,OAAO,MAAM,KAAK,UAAU,EAAE;AAC9B,iCAAS,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;qBACtC;AACD,wBAAI,SAAS,CAAC,KAAK,EAAE,EAAE;AACnB,iCAAS;qBACZ;;;;AAID,0BAAM,CAAC,SAAS,IAAI,SAAS,YAAY,EAAE,CAAC,SAAS,qCAAmC,SAAS,uBAAoB,CAAC;AACtH,4BAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;AACrC,wBAAI,QAAQ,EAAE;AACV,6BAAK,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE;;;AAGnD,qCAAS,CAAC,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AAC5D,qCAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;yBAC1C;qBACJ;AACD,4BAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,aAAa,CAAC,CAAC;AACrD,wBAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,EAAE;AAC7B,iCAAS,GAAG,SAAS,CAAC,UAAU,EAAE,CAAC;AACnC,6BAAK,IAAI,GAAG,QAAQ,CAAC,MAAM,EAAE,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,IAAI,EAAE,EAAE,IAAI,EAAE;AACxD,qCAAS,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AAC7D,qCAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC;yBAC3C;qBACJ;iBACJ;aACJ;;;eAzKC,KAAK;;;AA2KX,QAAI,OAAO,GAAG,KAAK,CAAC;;;;QAGd,KAAK;AACI,iBADT,KAAK,CACK,SAAS,EAAE;kCADrB,KAAK;;AAEH,gBAAI,CAAC,IAAI,GAAG,SAAS,CAAC;AACtB,gBAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AACtB,qBAAS,UAAU,CAAC,GAAG,EAAE,IAAI,EAAE;AAC3B,oBAAI,MAAM,GAAG,SAAT,MAAM,CAAa,KAAK,EAAE,GAAG,EAAE;AAC/B,uBAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;iBACvB,CAAC;AACF,qBAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;AAC3C,wBAAI,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,uBAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;iBACvB;AACD,uBAAO,GAAG,CAAC;aACd;AACD,gBAAI,CAAC,KAAK,GAAG;AACT,uBAAO,EAAE,CAAA,YAAmB;sDAAN,IAAI;AAAJ,4BAAI;;;AACtB,wBAAI,MAAM,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC5C,2BAAO,MAAM,CAAC;iBACjB,CAAA,CAAC,IAAI,CAAC,IAAI,CAAC;AACZ,yBAAS,EAAE,CAAA,YAAmB;uDAAN,IAAI;AAAJ,4BAAI;;;AACxB,wBAAI,MAAM,GAAG,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;AAC9C,2BAAO,MAAM,CAAC;iBACjB,CAAA,CAAC,IAAI,CAAC,IAAI,CAAC;aACf,CAAC;;AAEF,gBAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;AACzB,gBAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;;AAE3B,gBAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;AACzB,gBAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;AAC3B,gBAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;SAC5B;;qBA/BC,KAAK;;;;;;;;;;;;;;;;mBA6CE,mBAAC,IAAI,EAAE;AAAE,uBAAO,IAAI,CAAC;aAAE;;;;;;;;;;;;;;;;;;;mBAgB3B,eAAC,IAAI,EAAE,IAAI,EAAE;AAAE,uBAAO,IAAI,CAAC;aAAE;;;;;;;;;;;;;;;mBAY3B,iBAAC,IAAI,EAAE,EAAG;;;;;;;;;;;;;;;mBAYT,kBAAC,IAAI,EAAE,EAAG;;;;;;;;;;mBAOX,iBAAC,IAAI,EAAE;AACV,oBAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAC7B,oBAAI,CAAC,OAAO,UAAO,CAAC,IAAI,CAAC,CAAC;AAC1B,uBAAO,KAAK,CAAC,MAAM,CAAC;AACpB,uBAAO,KAAK,CAAC;aAChB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA0BI,eAAC,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE;AAC5B,oBAAI,MAAM,GAAG,IAAI,CAAC;AAClB,oBAAI,MAAM,CAAC;AACX,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,2BAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;iBACjC;;;AAGD,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,wBAAI,SAAS,CAAC,MAAM,EAAE;AAClB,iCAAS,CAAC,MAAM,GAAG,IAAI,CAAC;AACxB,4BAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAClC,+BAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBACjC,MACI;AACD,8BAAM,CAAC,KAAK,EAAE,gDAAgD,GAC1D,0BAA0B,CAAC,CAAC;qBACnC;iBACJ;AACD,sBAAM,GAAG,IAAI,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AACzC,oBAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AAC/B,yBAAS,CAAC,MAAM,GAAG,IAAI,CAAC;AACxB,sBAAM,CAAC,MAAM,GAAG,YAAY;AACxB,0BAAM,CAAC,OAAO,UAAO,CAAC,IAAI,CAAC,CAAC;AAC5B,2BAAO,IAAI,CAAC;iBACf,CAAC;AACF,uBAAO,MAAM,CAAC;aACjB;;;;;;;;;;;;;;;;mBAaK,gBAAC,cAAc,EAAE,KAAK,EAAE;AAC1B,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,2BAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;iBAC7C;AACD,oBAAI,CAAC,SAAS,CAAC,GAAG,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;AAC1C,uBAAO,KAAK,CAAC;aAChB;;;;;;;;;;;;;;;;mBAaG,cAAC,OAAO,EAAE;AACV,oBAAI,KAAK,EAAE,cAAc,CAAC;AAC1B,oBAAI,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AACnC,oBAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;;;;;AACnB,yCAAc,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,8HAAE;AAAhC,6BAAK;;AACN,6BAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBACpB;;;;;;;;;;;;;;;;;;;;;AACD,0CAAyC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,mIAAE;;;4BAAzD,cAAc;4BAAE,UAAU;;AAChC,sCAAc,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACtE,kCAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;qBACnC;;;;;;;;;;;;;;;;AACD,oBAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AACrB,oBAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;aACvB;;;;;;;;;;;;;;;;;;;;;;;;;;mBAuBC,YAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AACxB,oBAAI,MAAM,CAAC;AACX,oBAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACxB,0BAAM,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;iBACnC,MACI;AACD,0BAAM,GAAG,IAAI,GAAG,EAAE,CAAC;iBACtB;AACD,sBAAM,CAAC,GAAG,CAAC;AACP,4BAAQ,EAAE,QAAQ;AAClB,2BAAO,EAAE,OAAO,IAAI,IAAI;AACxB,0BAAM,EAAE,IAAI;iBACf,CAAC,CAAC;AACH,oBAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AAC/B,uBAAO,IAAI,CAAC;aACf;;;;;;;;;;;;;;;;;;;;mBAiBG,cAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC1B,oBAAI,IAAI,GAAG,IAAI,CAAC;AAChB,oBAAI,KAAK,GAAG,SAAR,KAAK,GAAe;AACpB,wBAAI,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACtB,4BAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;iBACnC,CAAC;AACF,uBAAO,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aACxC;;;;;;;;;;;;;;;;;;;;;mBAkBE,aAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;;AAEzB,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,wBAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;AACrB,2BAAO,IAAI,CAAC;iBACf;;AAED,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,wBAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACxB,4BAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;qBAClC;AACD,2BAAO,IAAI,CAAC;iBACf;;;AAGD,oBAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,UAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAK;AAClD,wBAAI,AAAC,QAAQ,IAAI,QAAQ,KAAK,KAAK,CAAC,QAAQ,IACvC,OAAO,IAAI,OAAO,KAAK,KAAK,CAAC,OAAO,AAAC,EAAE;AACxC,2BAAG,UAAO,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACJ,CAAC,CAAC;AACH,uBAAO,IAAI,CAAC;aACf;;;;;;;;;;;;;;;mBAYM,iBAAC,IAAI,EAAW;mDAAN,IAAI;AAAJ,wBAAI;;;AACjB,oBAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACxB,wBAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,UAAC,KAAK,EAAK;;;AACtC,2CAAA,KAAK,CAAC,QAAQ,EAAC,IAAI,MAAA,mBAAC,KAAK,CAAC,OAAO,SAAK,IAAI,EAAC,CAAC;qBAC/C,CAAC,CAAC;iBACN;AACD,uBAAO,IAAI,CAAC;aACf;;;;;;;;;;;;mBASK,gBAAC,YAAY,EAAE,KAAK,EAAE;AACxB,oBAAI,GAAG,CAAC;AACR,oBAAI,UAAU,CAAC;AACf,oBAAI,MAAM,GAAG,IAAI,CAAC;AAClB,yBAAS,aAAa,GAAG;AACrB,6BAAS,mBAAmB,CAAC,GAAG,EAAE,YAAY,EAAE;AAC5C,4BAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,CAAC,UAAU,IAAI,EAAE;AAAE,mCAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;yBAAE,CAAC,CAAC,CAAC;AACxF,+BAAO,YAAY,GAAG,GAAG,CAAC;qBAC7B;AACD,wBAAI,UAAU,CAAC,SAAS,KAAK,IAAI,EAAE;AAC/B,kCAAU,CAAC,UAAU,GAAG,mBAAmB,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;qBACtF,MACI,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;AAC1C,kCAAU,CAAC,UAAU,GAAG,mBAAmB,CAAC,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;qBACvF,MACI;AACD,kCAAU,CAAC,UAAU,GAAG,mBAAmB,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;qBACzF;iBACJ;AACD,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,2BAAO,IAAI,CAAC,OAAO,CAAC;iBACvB;AACD,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,wBAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;AAClC,6BAAK,GAAG,IAAI,YAAY,EAAE;AACtB,gCAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AACvB,0CAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACnC,oCAAI,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;AACrC,8CAAU,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;iCAC5E,MACI;AACD,8CAAU,CAAC,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;iCACxC;AACD,oCAAI,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE;AACxC,iDAAa,EAAE,CAAC;iCACnB;AACD,oCAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;6BACrC,MACI;AACD,uCAAO,CAAC,IAAI,uBAAqB,YAAY,sBAAmB,CAAC;6BACpE;yBACJ;AACD,+BAAO,IAAI,CAAC;qBACf;AACD,0BAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,OAAK,YAAY,6BAA0B,CAAC;AACjF,8BAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAC5C,wBAAI,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;AACrC,+BAAO,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBAC7C;AACD,2BAAO,UAAU,CAAC,KAAK,CAAC;iBAC3B;AACD,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,wBAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;AAChC,kCAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAC5C,4BAAI,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;AACrC,sCAAU,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;yBAChE,MACI;AACD,sCAAU,CAAC,KAAK,GAAG,KAAK,CAAC;yBAC5B;AACD,4BAAI,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE;AACxC,yCAAa,EAAE,CAAC;yBACnB;AACD,4BAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;qBAC9C,MACI;AACD,+BAAO,CAAC,IAAI,uBAAqB,YAAY,sBAAmB,CAAC;qBACpE;AACD,2BAAO,IAAI,CAAC;iBACf;aACJ;;;;;;;;;;;;mBASO,kBAAC,IAAI,EAAE,KAAK,EAAE;AAClB,oBAAI,GAAG,CAAC;AACR,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,2BAAO,IAAI,CAAC,SAAS,CAAC;iBACzB;AACD,oBAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,wBAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AAC1B,8BAAM,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,OAAK,IAAI,+BAA4B,CAAC;AACrE,+BAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;qBACnC,MACI;AACD,6BAAK,GAAG,IAAI,IAAI,EAAE;AACd,gCAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;yBACtC;qBACJ;iBACJ,MACI;AACD,wBAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;iBACnC;AACD,uBAAO,IAAI,CAAC;aACf;;;;;;;;;mBAMY,gBAAC,IAAI,EAAE;oBACV,QAAQ;AACC,6BADT,QAAQ,CACE,SAAS,EAAE;8CADrB,QAAQ;;AAEN,4BAAI,GAAG,CAAC;AACR,mDAHF,QAAQ,6CAGA,SAAS,EAAE;AACjB,4BAAI,OAAO,IAAI,KAAK,UAAU,EAAE;AAC5B,gCAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBACnB,MACI;AACD,iCAAK,GAAG,IAAI,IAAI,EAAE;AACd,oCAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;6BACzB;AACD,gCAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAC9B;qBACJ;;8BAbC,QAAQ;;2BAAR,QAAQ;mBAAS,IAAI;;AAe3B,uBAAO,QAAQ,CAAC;aACnB;;;eA/bC,KAAK;;;AAicX,QAAI,MAAM,GAAG,KAAK,CAAC;;;AAGnB,UAAM,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;AACjC,QAAI,IAAI,GAAG,EAAE,CAAC;AACd,QAAI,CAAC,IAAI,GAAG,MAAM,CAAC;AACnB,QAAI,KAAK,GAAG,IAAI,CAAC;;AAEjB,WAAO,KAAK,CAAC;CAEhB,CAAC,CAAE","sourceRoot":"/source/","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('d3')) :\n    typeof define === 'function' && define.amd ? define(['d3'], factory) :\n    global.koto = factory(global.d3)\n}(this, function (d3) { 'use strict';\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    /**\n     * Simple Assertion function\n     * @param  {anything} test    Anything that will evaluate to true of false.\n     * @param  {string} message The error message to send if `test` is false\n     */\n    function kotoAssert(test, message) {\n        if (test) {\n            return;\n        }\n        throw new Error(`[koto] ${message}`);\n    }\n    var assert = kotoAssert;\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    class Layer {\n        constructor(base, options) {\n            this._base = base;\n            this._handlers = {};\n            this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n            if (options) {\n                // Set layer methods (required)\n                this.dataBind = options.dataBind;\n                this.insert = options.insert;\n                // Bind events (optional)\n                if ('events' in options) {\n                    for (let eventName in options.events) {\n                        this.on(eventName, options.events[eventName]);\n                    }\n                }\n            }\n        }\n        /**\n         * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n         * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n         *\n         * @param {Array} data Value passed to {@link Layer#draw}\n         */\n        dataBind(data) {\n            assert(false, 'Layers must specify a dataBind method.');\n        }\n        /**\n         * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n         * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n         * Layer instances.\n         */\n        insert() {\n            assert(false, 'Layers must specify an `insert` method.');\n        }\n        /**\n         * Subscribe a handler to a \"lifecycle event\". These events (and only these\n         * events) are triggered when {@link Layer#draw} is invoked--see that method\n         * for more details on lifecycle events.\n         *\n         * @param {String} eventName Identifier for the lifecycle event for which to\n         *        subscribe.\n         * @param {Function} handler Callback function\n         *\n         * @returns {Chart} Reference to the layer instance (chaining).\n         */\n        on(eventName, handler, options) {\n            options = options || {};\n            assert(this._lifecycleRe.test(eventName), `Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n            if (!(eventName in this._handlers)) {\n                this._handlers[eventName] = [];\n            }\n            this._handlers[eventName].push({\n                callback: handler,\n                chart: options.chart || null\n            });\n            return this;\n        }\n        /**\n         * Unsubscribe the specified handler from the specified event. If no handler is\n         * supplied, remove *all* handlers from the event.\n         *\n         * @param {String} eventName Identifier for event from which to remove\n         *        unsubscribe\n         * @param {Function} handler Callback to remove from the specified event\n         *\n         * @returns {Chart} Reference to the layer instance (chaining).\n         */\n        off(eventName, handler) {\n            var handlers = this._handlers[eventName];\n            var idx;\n            assert(this._lifecycleRe.test(eventName), `Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n            if (!handlers) {\n                return this;\n            }\n            if (arguments.length === 1) {\n                handlers.length = 0;\n                return this;\n            }\n            for (idx = handlers.length - 1; idx > -1; --idx) {\n                if (handlers[idx].callback === handler) {\n                    handlers.splice(idx, 1);\n                }\n            }\n            return this;\n        }\n        /**\n         * Render the layer according to the input data: Bind the data to the layer\n         * (according to {@link Layer#dataBind}, insert new elements (according to\n         * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n         * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n         *\n         * - update\n         * - update:transition\n         * - enter\n         * - enter:transition\n         * - exit\n         * - exit:transition\n         *\n         * @param {Array} data Data to drive the rendering.\n         */\n        draw(data) {\n            var bound, entering, events, selection, method, handlers, eventName, idx, len, tidx, tlen;\n            bound = this.dataBind.call(this._base, data);\n            assert(bound instanceof d3.selection, 'Invalid selection defined by `Layer#dataBind` method.');\n            assert(bound.enter, 'Layer selection not properly bound.');\n            entering = bound.enter();\n            entering._chart = this._base._chart;\n            events = [\n                {\n                    name: 'update',\n                    selection: bound\n                },\n                {\n                    name: 'enter',\n                    selection: entering,\n                    method: this.insert\n                },\n                {\n                    name: 'merge',\n                    // Although the `merge` lifecycle event shares its selection object\n                    // with the `update` lifecycle event, the object's contents will be\n                    // modified when d3.chart invokes the user-supplied `insert` method\n                    // when triggering the `enter` event.\n                    selection: bound\n                },\n                {\n                    name: 'exit',\n                    // Although the `exit` lifecycle event shares its selection object\n                    // with the `update` and `merge` lifecycle events, the object's\n                    // contents will be modified when d3.chart invokes\n                    // `d3.selection.exit`.\n                    selection: bound,\n                    method: bound.exit\n                }\n            ];\n            for (var i = 0, l = events.length; i < l; ++i) {\n                eventName = events[i].name;\n                selection = events[i].selection;\n                method = events[i].method;\n                // Some lifecycle selections modify shared state, so they must be\n                // deferred until just prior to handler invocation.\n                if (typeof method === 'function') {\n                    selection = method.call(selection);\n                }\n                if (selection.empty()) {\n                    continue;\n                }\n                // Although `selection instanceof d3.selection` is more explicit,\n                // it fails in IE8, so we use duck typing to maintain\n                // compatability.\n                assert(selection && selection instanceof d3.selection, `Invalid selection defined for ${eventName} lifecycle event.`);\n                handlers = this._handlers[eventName];\n                if (handlers) {\n                    for (idx = 0, len = handlers.length; idx < len; ++idx) {\n                        // Attach a reference to the parent chart so the selection\"s\n                        // `chart` method will function correctly.\n                        selection._chart = handlers[idx].chart || this._base._chart;\n                        selection.call(handlers[idx].callback);\n                    }\n                }\n                handlers = this._handlers[eventName + ':transition'];\n                if (handlers && handlers.length) {\n                    selection = selection.transition();\n                    for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n                        selection._chart = handlers[tidx].chart || this._base._chart;\n                        selection.call(handlers[tidx].callback);\n                    }\n                }\n            }\n        }\n    }\n    var __layer = Layer;\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    class Chart {\n        constructor(selection) {\n            this.base = selection; // Container for chart @type {d3.selection}.\n            this.hasDrawn = false; // Has this chart been drawn at lease once?\n            function baseExtend(dst, maps) {\n                var setDst = function (value, key) {\n                    dst.set(key, value);\n                };\n                for (var i = 0, ii = maps.length; i < ii; ++i) {\n                    var map = maps[i];\n                    map.forEach(setDst);\n                }\n                return dst;\n            }\n            this.merge = {\n                configs: function (...args) {\n                    var merged = baseExtend(this.configs, args);\n                    return merged;\n                }.bind(this),\n                accessors: function (...args) {\n                    var merged = baseExtend(this.accessors, args);\n                    return merged;\n                }.bind(this)\n            };\n            // exposed properties\n            this.configs = new Map();\n            this.accessors = new Map();\n            // private\n            this._layers = new Map();\n            this._attached = new Map();\n            this._events = new Map();\n        }\n        /**\n         * A \"hook\" method that you may define to modify input data before it is used\n         * to draw the chart's layers and attachments. This method will be used by all\n         * sub-classes.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param {Array} data Input data provided to @link Chart#draw}.\n         * @returns {mixed} Data to be used in drawing the chart's layers and\n         *                  attachments.\n         */\n        transform(data) { return data; }\n        /**\n         * A \"hook\" method that you may define to choose which mutation of the input\n         * data is sent to which of the attached charts (by name). This method will\n         * be used by all sub-classes. This only applies to charts that use the\n         * {@link Chart#attach} method.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n         * @param {Array} data Input data provided to {@link Chart#draw}.\n         * @returns {mixed} Data to be used in drawing the chart's layers and\n         *                  attachments.\n         */\n        demux(name, data) { return data; }\n        /**\n         * A \"hook\" method that will allow you to run some arbitrary code before\n         * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param  {[type]} data [description]\n         * @return {[type]}      [description]\n         */\n        preDraw(data) { }\n        /**\n         * A \"hook\" method that will allow you to run some arbitrary code after\n         * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param  {[type]} data [description]\n         * @return {[type]}      [description]\n         */\n        postDraw(data) { }\n        /**\n         * Remove a layer from the chart.\n         *\n         * @param {String} name The name of the layer to remove.\n         * @returns {Layer} The layer removed by this operation.\n         */\n        unlayer(name) {\n            var layer = this.layer(name);\n            this._layers.delete(name);\n            delete layer._chart;\n            return layer;\n        }\n        /**\n         * Interact with the chart's {@link Layer|layers}.\n         *\n         * If only a `name` is provided, simply return the layer registered to that\n         * name (if any).\n         *\n         * If a `name` and `selection` are provided, treat the `selection` as a\n         * previously-created layer and attach it to the chart with the specified\n         * `name`.\n         *\n         * If all three arguments are specified, initialize a new {@link Layer} using\n         * the specified `selection` as a base passing along the specified `options`.\n         *\n         * The {@link Layer.draw} method of attached layers will be invoked\n         * whenever this chart's {@link Chart#draw} is invoked and will receive the\n         * data (optionally modified by the chart's {@link Chart#transform} method.\n         *\n         * @param {String} name Name of the layer to attach or retrieve.\n         * @param {d3.selection|Layer} [selection] The layer's base or a\n         *        previously-created {@link Layer}.\n         * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n         *        constructor}\n         *\n         * @returns {Layer}\n         */\n        layer(name, selection, options) {\n            var _Chart = this;\n            var _layer;\n            if (arguments.length === 1) {\n                return this._layers.get(name);\n            }\n            // we are reattaching a previous layer, which the\n            // selection argument is now set to.\n            if (arguments.length === 2) {\n                if (selection._chart) {\n                    selection._chart = this;\n                    this._layers.set(name, selection);\n                    return this._layers.get(name);\n                }\n                else {\n                    assert(false, 'When reattaching a layer, the second argument ' +\n                        'must be a d3.chart layer');\n                }\n            }\n            _layer = new __layer(selection, options);\n            this._layers.set(name, _layer);\n            selection._chart = this;\n            _layer.remove = function () {\n                _Chart._layers.delete(name);\n                return this;\n            };\n            return _layer;\n        }\n        /**\n         * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n         * method will be invoked whenever the containing chart's `draw` method is\n         * invoked.\n         *\n         * @param {String} attachmentName Name of the attachment\n         * @param {Chart} [chart] koto to register as a mix in of this chart. When\n         *        unspecified, this method will return the attachment previously\n         *        registered with the specified `attachmentName` (if any).\n         *\n         * @returns {Chart} Reference to this chart (chainable).\n         */\n        attach(attachmentName, chart) {\n            if (arguments.length === 1) {\n                return this._attached.get(attachmentName);\n            }\n            this._attached.set(attachmentName, chart);\n            return chart;\n        }\n        /**\n         * Update the chart's representation in the DOM, drawing all of its layers and\n         * any \"attachment\" charts (as attached via {@link Chart#attach}).\n         *\n         * Note: The first time you call this method, the property `hasDrawn` will be\n         * set to true. This is helpful if you want to only run some code on the first\n         * time the chart is drawn.\n         *\n         * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n         *        this cart's {@link Layer|layers} (if any) and the {@link\n         *        Chart#draw|draw method} of this chart's attachments (if any).\n         */\n        draw(rawData) {\n            var layer, attachmentData;\n            var data = this.transform(rawData);\n            this.preDraw(data);\n            for (layer of this._layers.values()) {\n                layer.draw(data);\n            }\n            for (let [attachmentName, attachment] of this._attached.entries()) {\n                attachmentData = this.demux ? this.demux(attachmentName, data) : data;\n                attachment.draw(attachmentData);\n            }\n            this.hasDrawn = true;\n            this.postDraw(data);\n        }\n        /**\n         * Function invoked with the context specified when the handler was bound (via\n         * {@link Chart#on} {@link Chart#once}).\n         *\n         * @callback ChartEventHandler\n         * @param {...*} arguments Invoked with the arguments passed to {@link\n         *         Chart#trigger}\n         */\n        /**\n         * Subscribe a callback function to an event triggered on the chart. See {@link\n         * Chart#once} to subscribe a callback function to an event for one occurence.\n         *\n         * @externalExample {runnable} chart-on\n         *\n         * @param {String} name Name of the event\n         * @param {ChartEventHandler} callback Function to be invoked when the event\n         *        occurs\n         * @param {Object} [context] Value to set as `this` when invoking the\n         *        `callback`. Defaults to the chart instance.\n         *\n         * @returns {Chart} A reference to this chart (chainable).\n         */\n        on(name, callback, context) {\n            var events;\n            if (this._events.has(name)) {\n                events = this._events.get(name);\n            }\n            else {\n                events = new Set();\n            }\n            events.add({\n                callback: callback,\n                context: context || this,\n                _chart: this\n            });\n            this._events.set(name, events);\n            return this;\n        }\n        /**\n         * Subscribe a callback function to an event triggered on the chart. This\n         * function will be invoked at the next occurance of the event and immediately\n         * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n         * event indefinitely.\n         *\n         * @externalExample {runnable} chart-once\n         *\n         * @param {String} name Name of the event\n         * @param {ChartEventHandler} callback Function to be invoked when the event\n         *        occurs\n         * @param {Object} [context] Value to set as `this` when invoking the\n         *        `callback`. Defaults to the chart instance\n         *\n         * @returns {Chart} A reference to this chart (chainable)\n         */\n        once(name, callback, context) {\n            var self = this;\n            var _once = function () {\n                self.off(name, _once);\n                callback.apply(this, arguments);\n            };\n            return this.on(name, _once, context);\n        }\n        /**\n         * Unsubscribe one or more callback functions from an event triggered on the\n         * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n         * When only a `name` is specified, all handlers subscribed to that event will\n         * be unsubscribed. When a `name` and `callback` are specified, only that\n         * function will be unsubscribed from that event. When a `name` and `context`\n         * are specified (but `callback` is omitted), all events bound to the given\n         * event with the given context will be unsubscribed.\n         *\n         * @externalExample {runnable} chart-off\n         *\n         * @param {String} [name] Name of the event to be unsubscribed\n         * @param {ChartEventHandler} [callback] Function to be unsubscribed\n         * @param {Object} [context] Contexts to be unsubscribe\n         *\n         * @returns {Chart} A reference to this chart (chainable).\n         */\n        off(name, callback, context) {\n            // remove all events\n            if (arguments.length === 0) {\n                this._events.clear();\n                return this;\n            }\n            // remove all events for a specific name\n            if (arguments.length === 1) {\n                if (this._events.has(name)) {\n                    this._events.get(name).clear();\n                }\n                return this;\n            }\n            // remove all events that match whatever combination of name, context\n            // and callback.\n            this._events.get(name).forEach((event, clone, map) => {\n                if ((callback && callback === clone.callback) ||\n                    (context && context === clone.context)) {\n                    map.delete(event);\n                }\n            });\n            return this;\n        }\n        /**\n         * Publish an event on this chart with the given `name`.\n         *\n         * @externalExample {runnable} chart-trigger\n         *\n         * @param {String} name Name of the event to publish\n         * @param {...*} arguments Values with which to invoke the registered\n         *        callbacks.\n         *\n         * @returns {Chart} A reference to this chart (chainable).\n         */\n        trigger(name, ...args) {\n            if (this._events.has(name)) {\n                this._events.get(name).forEach((event) => {\n                    event.callback.call(event.context, ...args);\n                });\n            }\n            return this;\n        }\n        /**\n         * Get and set chart options (or configs)\n         *\n         * @param  {mixed} nameOrObject name of item getting or setting\n         *                              or its an object with key value pairs.\n         * @param  {mixed} value the value for config item witha that name.\n         * @return {mixed} if getting, its the value. if setting it is the chart instance.\n         */\n        config(nameOrObject, value) {\n            var key;\n            var definition;\n            var _Chart = this;\n            function setPercentage() {\n                function calcultePerecentage(arr, initialValue) {\n                    var min = Math.min.call(null, arr.map(function (name) { return _Chart.config(name); }));\n                    return initialValue / min;\n                }\n                if (definition.constrain === true) {\n                    definition.percentage = calcultePerecentage(['width', 'height'], definition.value);\n                }\n                else if (Array.isArray(definition.constrain)) {\n                    definition.percentage = calcultePerecentage(definition.constrain, definition.value);\n                }\n                else {\n                    definition.percentage = calcultePerecentage([definition.constrain], definition.value);\n                }\n            }\n            if (arguments.length === 0) {\n                return this.configs;\n            }\n            if (arguments.length === 1) {\n                if (typeof nameOrObject === 'object') {\n                    for (key in nameOrObject) {\n                        if (this.configs.has(key)) {\n                            definition = this.configs.get(key);\n                            if (definition.hasOwnProperty('setter')) {\n                                definition.value = definition.setter.call(definition, nameOrObject[key]);\n                            }\n                            else {\n                                definition.value = nameOrObject[key];\n                            }\n                            if (definition.hasOwnProperty('constrain')) {\n                                setPercentage();\n                            }\n                            this.configs.set(key, definition);\n                        }\n                        else {\n                            console.warn(`config with name ${nameOrObject} is not defined.`);\n                        }\n                    }\n                    return this;\n                }\n                assert(this.configs.has(nameOrObject), `${nameOrObject} is not a valid option.`);\n                definition = this.configs.get(nameOrObject);\n                if (definition.hasOwnProperty('getter')) {\n                    return definition.getter.call(definition);\n                }\n                return definition.value;\n            }\n            if (arguments.length === 2) {\n                if (this.configs.has(nameOrObject)) {\n                    definition = this.configs.get(nameOrObject);\n                    if (definition.hasOwnProperty('setter')) {\n                        definition.value = definition.setter.call(definition, value);\n                    }\n                    else {\n                        definition.value = value;\n                    }\n                    if (definition.hasOwnProperty('constrain')) {\n                        setPercentage();\n                    }\n                    this.configs.set(nameOrObject, definition);\n                }\n                else {\n                    console.warn(`config with name ${nameOrObject} is not defined.`);\n                }\n                return this;\n            }\n        }\n        /**\n         * This will get or set any of the chart's accessors.\n         *\n         * @param  {String or Object} item If string, it will return the function for that accessor item.\n         *                                 If object, it will update that accessor with set function.\n         * @param  {function} [value] The function to update accessor item with.\n         * @return {object} The chart to preserve chainability.\n         */\n        accessor(item, value) {\n            var key;\n            if (arguments.length === 0) {\n                return this.accessors;\n            }\n            if (arguments.length === 1) {\n                if (typeof item === 'string') {\n                    assert(this.accessors.has(item), `${item} is not a valid accessor.`);\n                    return this.accessors.get(item);\n                }\n                else {\n                    for (key in item) {\n                        this.accessors.set(key, item[key]);\n                    }\n                }\n            }\n            else {\n                this.accessors.set(item, value);\n            }\n            return this;\n        }\n        /**\n         * This will extend a chart by passing in an object of initialize function.\n         * @param  {Object || function} init Initialize function of object with initialize method.\n         * @return {Construtor}      Chart constructor\n         */\n        static extend(init) {\n            class Extended extends this {\n                constructor(selection) {\n                    var key;\n                    super(selection);\n                    if (typeof init === 'function') {\n                        init.call(this);\n                    }\n                    else {\n                        for (key in init) {\n                            this[key] = init[key];\n                        }\n                        init.initialize.call(this);\n                    }\n                }\n            }\n            return Extended;\n        }\n    }\n    var _chart = Chart;\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    assert(d3, 'd3 js is required.');\n    var koto = {};\n    koto.Base = _chart;\n    var index = koto;\n\n    return index;\n\n}));\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('d3')) :\n    typeof define === 'function' && define.amd ? define(['d3'], factory) :\n    global.koto = factory(global.d3)\n}(this, function (d3) { 'use strict';\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    /**\n     * Simple Assertion function\n     * @param  {anything} test    Anything that will evaluate to true of false.\n     * @param  {string} message The error message to send if `test` is false\n     */\n    function kotoAssert(test, message) {\n        if (test) {\n            return;\n        }\n        throw new Error(`[koto] ${message}`);\n    }\n    var assert = kotoAssert;\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    class Layer {\n        constructor(base, options) {\n            this._base = base;\n            this._handlers = {};\n            this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n            if (options) {\n                // Set layer methods (required)\n                this.dataBind = options.dataBind;\n                this.insert = options.insert;\n                // Bind events (optional)\n                if ('events' in options) {\n                    for (let eventName in options.events) {\n                        this.on(eventName, options.events[eventName]);\n                    }\n                }\n            }\n        }\n        /**\n         * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n         * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n         *\n         * @param {Array} data Value passed to {@link Layer#draw}\n         */\n        dataBind(data) {\n            assert(false, 'Layers must specify a dataBind method.');\n        }\n        /**\n         * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n         * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n         * Layer instances.\n         */\n        insert() {\n            assert(false, 'Layers must specify an `insert` method.');\n        }\n        /**\n         * Subscribe a handler to a \"lifecycle event\". These events (and only these\n         * events) are triggered when {@link Layer#draw} is invoked--see that method\n         * for more details on lifecycle events.\n         *\n         * @param {String} eventName Identifier for the lifecycle event for which to\n         *        subscribe.\n         * @param {Function} handler Callback function\n         *\n         * @returns {Chart} Reference to the layer instance (chaining).\n         */\n        on(eventName, handler, options) {\n            options = options || {};\n            assert(this._lifecycleRe.test(eventName), `Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n            if (!(eventName in this._handlers)) {\n                this._handlers[eventName] = [];\n            }\n            this._handlers[eventName].push({\n                callback: handler,\n                chart: options.chart || null\n            });\n            return this;\n        }\n        /**\n         * Unsubscribe the specified handler from the specified event. If no handler is\n         * supplied, remove *all* handlers from the event.\n         *\n         * @param {String} eventName Identifier for event from which to remove\n         *        unsubscribe\n         * @param {Function} handler Callback to remove from the specified event\n         *\n         * @returns {Chart} Reference to the layer instance (chaining).\n         */\n        off(eventName, handler) {\n            var handlers = this._handlers[eventName];\n            var idx;\n            assert(this._lifecycleRe.test(eventName), `Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n            if (!handlers) {\n                return this;\n            }\n            if (arguments.length === 1) {\n                handlers.length = 0;\n                return this;\n            }\n            for (idx = handlers.length - 1; idx > -1; --idx) {\n                if (handlers[idx].callback === handler) {\n                    handlers.splice(idx, 1);\n                }\n            }\n            return this;\n        }\n        /**\n         * Render the layer according to the input data: Bind the data to the layer\n         * (according to {@link Layer#dataBind}, insert new elements (according to\n         * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n         * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n         *\n         * - update\n         * - update:transition\n         * - enter\n         * - enter:transition\n         * - exit\n         * - exit:transition\n         *\n         * @param {Array} data Data to drive the rendering.\n         */\n        draw(data) {\n            var bound, entering, events, selection, method, handlers, eventName, idx, len, tidx, tlen;\n            bound = this.dataBind.call(this._base, data);\n            assert(bound instanceof d3.selection, 'Invalid selection defined by `Layer#dataBind` method.');\n            assert(bound.enter, 'Layer selection not properly bound.');\n            entering = bound.enter();\n            entering._chart = this._base._chart;\n            events = [\n                {\n                    name: 'update',\n                    selection: bound\n                },\n                {\n                    name: 'enter',\n                    selection: entering,\n                    method: this.insert\n                },\n                {\n                    name: 'merge',\n                    // Although the `merge` lifecycle event shares its selection object\n                    // with the `update` lifecycle event, the object's contents will be\n                    // modified when d3.chart invokes the user-supplied `insert` method\n                    // when triggering the `enter` event.\n                    selection: bound\n                },\n                {\n                    name: 'exit',\n                    // Although the `exit` lifecycle event shares its selection object\n                    // with the `update` and `merge` lifecycle events, the object's\n                    // contents will be modified when d3.chart invokes\n                    // `d3.selection.exit`.\n                    selection: bound,\n                    method: bound.exit\n                }\n            ];\n            for (var i = 0, l = events.length; i < l; ++i) {\n                eventName = events[i].name;\n                selection = events[i].selection;\n                method = events[i].method;\n                // Some lifecycle selections modify shared state, so they must be\n                // deferred until just prior to handler invocation.\n                if (typeof method === 'function') {\n                    selection = method.call(selection);\n                }\n                if (selection.empty()) {\n                    continue;\n                }\n                // Although `selection instanceof d3.selection` is more explicit,\n                // it fails in IE8, so we use duck typing to maintain\n                // compatability.\n                assert(selection && selection instanceof d3.selection, `Invalid selection defined for ${eventName} lifecycle event.`);\n                handlers = this._handlers[eventName];\n                if (handlers) {\n                    for (idx = 0, len = handlers.length; idx < len; ++idx) {\n                        // Attach a reference to the parent chart so the selection\"s\n                        // `chart` method will function correctly.\n                        selection._chart = handlers[idx].chart || this._base._chart;\n                        selection.call(handlers[idx].callback);\n                    }\n                }\n                handlers = this._handlers[eventName + ':transition'];\n                if (handlers && handlers.length) {\n                    selection = selection.transition();\n                    for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n                        selection._chart = handlers[tidx].chart || this._base._chart;\n                        selection.call(handlers[tidx].callback);\n                    }\n                }\n            }\n        }\n    }\n    var __layer = Layer;\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    class Chart {\n        constructor(selection) {\n            this.base = selection; // Container for chart @type {d3.selection}.\n            this.hasDrawn = false; // Has this chart been drawn at lease once?\n            function baseExtend(dst, maps) {\n                var setDst = function (value, key) {\n                    dst.set(key, value);\n                };\n                for (var i = 0, ii = maps.length; i < ii; ++i) {\n                    var map = maps[i];\n                    map.forEach(setDst);\n                }\n                return dst;\n            }\n            this.merge = {\n                configs: function (...args) {\n                    var merged = baseExtend(this.configs, args);\n                    return merged;\n                }.bind(this),\n                accessors: function (...args) {\n                    var merged = baseExtend(this.accessors, args);\n                    return merged;\n                }.bind(this)\n            };\n            // exposed properties\n            this.configs = new Map();\n            this.accessors = new Map();\n            // private\n            this._layers = new Map();\n            this._attached = new Map();\n            this._events = new Map();\n        }\n        /**\n         * A \"hook\" method that you may define to modify input data before it is used\n         * to draw the chart's layers and attachments. This method will be used by all\n         * sub-classes.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param {Array} data Input data provided to @link Chart#draw}.\n         * @returns {mixed} Data to be used in drawing the chart's layers and\n         *                  attachments.\n         */\n        transform(data) { return data; }\n        /**\n         * A \"hook\" method that you may define to choose which mutation of the input\n         * data is sent to which of the attached charts (by name). This method will\n         * be used by all sub-classes. This only applies to charts that use the\n         * {@link Chart#attach} method.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n         * @param {Array} data Input data provided to {@link Chart#draw}.\n         * @returns {mixed} Data to be used in drawing the chart's layers and\n         *                  attachments.\n         */\n        demux(name, data) { return data; }\n        /**\n         * A \"hook\" method that will allow you to run some arbitrary code before\n         * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param  {[type]} data [description]\n         * @return {[type]}      [description]\n         */\n        preDraw(data) { }\n        /**\n         * A \"hook\" method that will allow you to run some arbitrary code after\n         * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n         *\n         * Note: you will most likely never call this method directly, but rather\n         * include it as part of a chart definition, and then rely on d3.chart to\n         * invoke it when you draw the chart with {@link Chart#draw}.\n         *\n         * @param  {[type]} data [description]\n         * @return {[type]}      [description]\n         */\n        postDraw(data) { }\n        /**\n         * Remove a layer from the chart.\n         *\n         * @param {String} name The name of the layer to remove.\n         * @returns {Layer} The layer removed by this operation.\n         */\n        unlayer(name) {\n            var layer = this.layer(name);\n            this._layers.delete(name);\n            delete layer._chart;\n            return layer;\n        }\n        /**\n         * Interact with the chart's {@link Layer|layers}.\n         *\n         * If only a `name` is provided, simply return the layer registered to that\n         * name (if any).\n         *\n         * If a `name` and `selection` are provided, treat the `selection` as a\n         * previously-created layer and attach it to the chart with the specified\n         * `name`.\n         *\n         * If all three arguments are specified, initialize a new {@link Layer} using\n         * the specified `selection` as a base passing along the specified `options`.\n         *\n         * The {@link Layer.draw} method of attached layers will be invoked\n         * whenever this chart's {@link Chart#draw} is invoked and will receive the\n         * data (optionally modified by the chart's {@link Chart#transform} method.\n         *\n         * @param {String} name Name of the layer to attach or retrieve.\n         * @param {d3.selection|Layer} [selection] The layer's base or a\n         *        previously-created {@link Layer}.\n         * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n         *        constructor}\n         *\n         * @returns {Layer}\n         */\n        layer(name, selection, options) {\n            var _Chart = this;\n            var _layer;\n            if (arguments.length === 1) {\n                return this._layers.get(name);\n            }\n            // we are reattaching a previous layer, which the\n            // selection argument is now set to.\n            if (arguments.length === 2) {\n                if (selection._chart) {\n                    selection._chart = this;\n                    this._layers.set(name, selection);\n                    return this._layers.get(name);\n                }\n                else {\n                    assert(false, 'When reattaching a layer, the second argument ' +\n                        'must be a d3.chart layer');\n                }\n            }\n            _layer = new __layer(selection, options);\n            this._layers.set(name, _layer);\n            selection._chart = this;\n            _layer.remove = function () {\n                _Chart._layers.delete(name);\n                return this;\n            };\n            return _layer;\n        }\n        /**\n         * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n         * method will be invoked whenever the containing chart's `draw` method is\n         * invoked.\n         *\n         * @param {String} attachmentName Name of the attachment\n         * @param {Chart} [chart] koto to register as a mix in of this chart. When\n         *        unspecified, this method will return the attachment previously\n         *        registered with the specified `attachmentName` (if any).\n         *\n         * @returns {Chart} Reference to this chart (chainable).\n         */\n        attach(attachmentName, chart) {\n            if (arguments.length === 1) {\n                return this._attached.get(attachmentName);\n            }\n            this._attached.set(attachmentName, chart);\n            return chart;\n        }\n        /**\n         * Update the chart's representation in the DOM, drawing all of its layers and\n         * any \"attachment\" charts (as attached via {@link Chart#attach}).\n         *\n         * Note: The first time you call this method, the property `hasDrawn` will be\n         * set to true. This is helpful if you want to only run some code on the first\n         * time the chart is drawn.\n         *\n         * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n         *        this cart's {@link Layer|layers} (if any) and the {@link\n         *        Chart#draw|draw method} of this chart's attachments (if any).\n         */\n        draw(rawData) {\n            var layer, attachmentData;\n            var data = this.transform(rawData);\n            this.preDraw(data);\n            for (layer of this._layers.values()) {\n                layer.draw(data);\n            }\n            for (let [attachmentName, attachment] of this._attached.entries()) {\n                attachmentData = this.demux ? this.demux(attachmentName, data) : data;\n                attachment.draw(attachmentData);\n            }\n            this.hasDrawn = true;\n            this.postDraw(data);\n        }\n        /**\n         * Function invoked with the context specified when the handler was bound (via\n         * {@link Chart#on} {@link Chart#once}).\n         *\n         * @callback ChartEventHandler\n         * @param {...*} arguments Invoked with the arguments passed to {@link\n         *         Chart#trigger}\n         */\n        /**\n         * Subscribe a callback function to an event triggered on the chart. See {@link\n         * Chart#once} to subscribe a callback function to an event for one occurence.\n         *\n         * @externalExample {runnable} chart-on\n         *\n         * @param {String} name Name of the event\n         * @param {ChartEventHandler} callback Function to be invoked when the event\n         *        occurs\n         * @param {Object} [context] Value to set as `this` when invoking the\n         *        `callback`. Defaults to the chart instance.\n         *\n         * @returns {Chart} A reference to this chart (chainable).\n         */\n        on(name, callback, context) {\n            var events;\n            if (this._events.has(name)) {\n                events = this._events.get(name);\n            }\n            else {\n                events = new Set();\n            }\n            events.add({\n                callback: callback,\n                context: context || this,\n                _chart: this\n            });\n            this._events.set(name, events);\n            return this;\n        }\n        /**\n         * Subscribe a callback function to an event triggered on the chart. This\n         * function will be invoked at the next occurance of the event and immediately\n         * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n         * event indefinitely.\n         *\n         * @externalExample {runnable} chart-once\n         *\n         * @param {String} name Name of the event\n         * @param {ChartEventHandler} callback Function to be invoked when the event\n         *        occurs\n         * @param {Object} [context] Value to set as `this` when invoking the\n         *        `callback`. Defaults to the chart instance\n         *\n         * @returns {Chart} A reference to this chart (chainable)\n         */\n        once(name, callback, context) {\n            var self = this;\n            var _once = function () {\n                self.off(name, _once);\n                callback.apply(this, arguments);\n            };\n            return this.on(name, _once, context);\n        }\n        /**\n         * Unsubscribe one or more callback functions from an event triggered on the\n         * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n         * When only a `name` is specified, all handlers subscribed to that event will\n         * be unsubscribed. When a `name` and `callback` are specified, only that\n         * function will be unsubscribed from that event. When a `name` and `context`\n         * are specified (but `callback` is omitted), all events bound to the given\n         * event with the given context will be unsubscribed.\n         *\n         * @externalExample {runnable} chart-off\n         *\n         * @param {String} [name] Name of the event to be unsubscribed\n         * @param {ChartEventHandler} [callback] Function to be unsubscribed\n         * @param {Object} [context] Contexts to be unsubscribe\n         *\n         * @returns {Chart} A reference to this chart (chainable).\n         */\n        off(name, callback, context) {\n            // remove all events\n            if (arguments.length === 0) {\n                this._events.clear();\n                return this;\n            }\n            // remove all events for a specific name\n            if (arguments.length === 1) {\n                if (this._events.has(name)) {\n                    this._events.get(name).clear();\n                }\n                return this;\n            }\n            // remove all events that match whatever combination of name, context\n            // and callback.\n            this._events.get(name).forEach((event, clone, map) => {\n                if ((callback && callback === clone.callback) ||\n                    (context && context === clone.context)) {\n                    map.delete(event);\n                }\n            });\n            return this;\n        }\n        /**\n         * Publish an event on this chart with the given `name`.\n         *\n         * @externalExample {runnable} chart-trigger\n         *\n         * @param {String} name Name of the event to publish\n         * @param {...*} arguments Values with which to invoke the registered\n         *        callbacks.\n         *\n         * @returns {Chart} A reference to this chart (chainable).\n         */\n        trigger(name, ...args) {\n            if (this._events.has(name)) {\n                this._events.get(name).forEach((event) => {\n                    event.callback.call(event.context, ...args);\n                });\n            }\n            return this;\n        }\n        /**\n         * Get and set chart options (or configs)\n         *\n         * @param  {mixed} nameOrObject name of item getting or setting\n         *                              or its an object with key value pairs.\n         * @param  {mixed} value the value for config item witha that name.\n         * @return {mixed} if getting, its the value. if setting it is the chart instance.\n         */\n        config(nameOrObject, value) {\n            var key;\n            var definition;\n            var _Chart = this;\n            function setPercentage() {\n                function calcultePerecentage(arr, initialValue) {\n                    var min = Math.min.call(null, arr.map(function (name) { return _Chart.config(name); }));\n                    return initialValue / min;\n                }\n                if (definition.constrain === true) {\n                    definition.percentage = calcultePerecentage(['width', 'height'], definition.value);\n                }\n                else if (Array.isArray(definition.constrain)) {\n                    definition.percentage = calcultePerecentage(definition.constrain, definition.value);\n                }\n                else {\n                    definition.percentage = calcultePerecentage([definition.constrain], definition.value);\n                }\n            }\n            if (arguments.length === 0) {\n                return this.configs;\n            }\n            if (arguments.length === 1) {\n                if (typeof nameOrObject === 'object') {\n                    for (key in nameOrObject) {\n                        if (this.configs.has(key)) {\n                            definition = this.configs.get(key);\n                            if (definition.hasOwnProperty('setter')) {\n                                definition.value = definition.setter.call(definition, nameOrObject[key]);\n                            }\n                            else {\n                                definition.value = nameOrObject[key];\n                            }\n                            if (definition.hasOwnProperty('constrain')) {\n                                setPercentage();\n                            }\n                            this.configs.set(key, definition);\n                        }\n                        else {\n                            console.warn(`config with name ${nameOrObject} is not defined.`);\n                        }\n                    }\n                    return this;\n                }\n                assert(this.configs.has(nameOrObject), `${nameOrObject} is not a valid option.`);\n                definition = this.configs.get(nameOrObject);\n                if (definition.hasOwnProperty('getter')) {\n                    return definition.getter.call(definition);\n                }\n                return definition.value;\n            }\n            if (arguments.length === 2) {\n                if (this.configs.has(nameOrObject)) {\n                    definition = this.configs.get(nameOrObject);\n                    if (definition.hasOwnProperty('setter')) {\n                        definition.value = definition.setter.call(definition, value);\n                    }\n                    else {\n                        definition.value = value;\n                    }\n                    if (definition.hasOwnProperty('constrain')) {\n                        setPercentage();\n                    }\n                    this.configs.set(nameOrObject, definition);\n                }\n                else {\n                    console.warn(`config with name ${nameOrObject} is not defined.`);\n                }\n                return this;\n            }\n        }\n        /**\n         * This will get or set any of the chart's accessors.\n         *\n         * @param  {String or Object} item If string, it will return the function for that accessor item.\n         *                                 If object, it will update that accessor with set function.\n         * @param  {function} [value] The function to update accessor item with.\n         * @return {object} The chart to preserve chainability.\n         */\n        accessor(item, value) {\n            var key;\n            if (arguments.length === 0) {\n                return this.accessors;\n            }\n            if (arguments.length === 1) {\n                if (typeof item === 'string') {\n                    assert(this.accessors.has(item), `${item} is not a valid accessor.`);\n                    return this.accessors.get(item);\n                }\n                else {\n                    for (key in item) {\n                        this.accessors.set(key, item[key]);\n                    }\n                }\n            }\n            else {\n                this.accessors.set(item, value);\n            }\n            return this;\n        }\n        /**\n         * This will extend a chart by passing in an object of initialize function.\n         * @param  {Object || function} init Initialize function of object with initialize method.\n         * @return {Construtor}      Chart constructor\n         */\n        static extend(init) {\n            class Extended extends this {\n                constructor(selection) {\n                    var key;\n                    super(selection);\n                    if (typeof init === 'function') {\n                        init.call(this);\n                    }\n                    else {\n                        for (key in init) {\n                            this[key] = init[key];\n                        }\n                        init.initialize.call(this);\n                    }\n                }\n            }\n            return Extended;\n        }\n    }\n    var _chart = Chart;\n\n    /// <reference path=\"../typings/tsd.d.ts\" />\n    assert(d3, 'd3 js is required.');\n    var koto = {};\n    koto.Base = _chart;\n    var index = koto;\n\n    return index;\n\n}));\n"]}