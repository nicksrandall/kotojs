{"version":3,"file":"koto.js","sources":["koto.js","/source/koto.js"],"names":["global","factory","exports","module","define","amd","koto","this","kotoAssert","test","message","Error","assert","Layer","base","options","_base","_handlers","_lifecycleRe","dataBind","insert","eventName","events","on","handler","push","callback","chart","idx","handlers","arguments","length","splice","data","bound","entering","selection","method","len","tidx","tlen","call","d3","enter","_chart","name","exit","i","l","empty","transition","__layer","Chart","baseExtend","dst","objs","isObject","value","isFunction","ii","obj","keys","Object","j","jj","key","src","hasDrawn","merge","configs","merged","config","accessors","accessor","Map","_layers","_attached","_events","_accessors","layer","_layer","_Chart","get","draw","set","remove","attachmentName","rawData","attachmentData","transform","preDraw","_step","_iterator","values","Symbol","iterator","_iteratorNormalCompletion","next","done","_step2","_iterator2","entries","_iteratorNormalCompletion2","_step2$value","attachment","demux","postDraw","reAttachmentData","preUpdate","_step3","_iterator3","_iteratorNormalCompletion3","_step4","_iterator4","_iteratorNormalCompletion4","reAttachmentName","_step4$value","reAttachment","postUpdate","context","has","Set","add","self","_once","_once2","off","apply","clear","forEach","event","clone","map","args","Array","_len","_key","_event$callback","concat","nameOrObject","definition","console","warn","item","Base","index"],"mappings":"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","sourceRoot":"/source/","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.koto = factory()\n}(this, function () { 'use strict';\n\n\t/**\n\t * Simple Assertion function\n\t * @param  {anything} test    Anything that will evaluate to true of false.\n\t * @param  {string} message The error message to send if `test` is false\n\t */\n\tfunction kotoAssert(test, message) {\n\t  if (test) {\n\t    return;\n\t  }\n\t  throw new Error(`[koto] ${message}`);\n\t}\n\n\tvar assert = kotoAssert;\n\n\tclass Layer {\n\t  constructor(base, options) {\n\t    this._base = base;\n\t    this._handlers = {};\n\t    this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n\t    if (options) {\n\t      // Set layer methods (required)\n\t      this.dataBind = options.dataBind;\n\t      this.insert = options.insert;\n\n\t      // Bind events (optional)\n\t      if ('events' in options) {\n\t        for (let eventName in options.events) {\n\t          this.on(eventName, options.events[eventName]);\n\t        }\n\t      }\n\t    }\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t\t *\n\t\t * @param {Array} data Value passed to {@link Layer#draw}\n\t\t */\n\t\tdataBind() {\n\t\t\tassert(false, 'Layers must specify a dataBind method.');\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t\t * Layer instances.\n\t\t */\n\t\tinsert() {\n\t\t\tassert(false, 'Layers must specify an `insert` method.');\n\t\t}\n\n\t\t/**\n\t\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t\t * for more details on lifecycle events.\n\t\t *\n\t\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t\t *        subscribe.\n\t\t * @param {Function} handler Callback function\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\ton(eventName, handler, options) {\n\t\t\toptions = options || {};\n\n\t\t\tassert(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!(eventName in this._handlers)) {\n\t\t\t\tthis._handlers[eventName] = [];\n\t\t\t}\n\t\t\tthis._handlers[eventName].push({\n\t\t\t\tcallback: handler,\n\t\t\t\tchart: options.chart || null\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t\t * supplied, remove *all* handlers from the event.\n\t\t *\n\t\t * @param {String} eventName Identifier for event from which to remove\n\t\t *        unsubscribe\n\t\t * @param {Function} handler Callback to remove from the specified event\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\toff(eventName, handler) {\n\t\t\tvar handlers = this._handlers[eventName];\n\t\t\tvar idx;\n\n\t\t\tassert(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!handlers) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (arguments.length === 1) {\n\t\t\t\thandlers.length = 0;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\t\thandlers.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Render the layer according to the input data: Bind the data to the layer\n\t\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t\t *\n\t\t * - update\n\t\t * - update:transition\n\t\t * - enter\n\t\t * - enter:transition\n\t\t * - exit\n\t\t * - exit:transition\n\t\t *\n\t\t * @param {Array} data Data to drive the rendering.\n\t\t */\n\t\tdraw(data) {\n\t\t\tvar bound,\n\t\t\t\tentering,\n\t\t\t\tevents,\n\t\t\t\tselection,\n\t\t\t\tmethod,\n\t\t\t\thandlers,\n\t\t\t\teventName,\n\t      idx,\n\t      len,\n\t      tidx,\n\t      tlen;\n\n\t\t\tbound = this.dataBind.call(this._base, data);\n\n\t\t\tassert(bound instanceof d3.selection,\n\t      'Invalid selection defined by `Layer#dataBind` method.');\n\t\t\tassert(bound.enter, 'Layer selection not properly bound.');\n\n\t\t\tentering = bound.enter();\n\t\t\tentering._chart = this._base._chart;\n\n\t\t\tevents = [\n\t\t\t\t{\n\t\t\t\t\tname: 'update',\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'enter',\n\t\t\t\t\tselection: entering,\n\t\t\t\t\tmethod: this.insert\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'merge',\n\t\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t\t// when triggering the `enter` event.\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'exit',\n\t\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t\t// `d3.selection.exit`.\n\t\t\t\t\tselection: bound,\n\t\t\t\t\tmethod: bound.exit\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\t\teventName = events[i].name;\n\t\t\t\tselection = events[i].selection;\n\t\t\t\tmethod = events[i].method;\n\n\t\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t\t// deferred until just prior to handler invocation.\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tselection = method.call(selection);\n\t\t\t\t}\n\n\t\t\t\tif (selection.empty()) {\n\t        continue;\n\t\t\t\t}\n\n\t\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t\t// compatability.\n\n\t\t\t\tassert(selection && selection instanceof d3.selection,\n\t        `Invalid selection defined for ${eventName} lifecycle event.`);\n\n\t\t\t\thandlers = this._handlers[eventName];\n\n\t      if (handlers) {\n\t        for (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t          // Attach a reference to the parent chart so the selection\"s\n\t          // `chart` method will function correctly.\n\t          selection._chart = handlers[idx].chart || this._base._chart;\n\t          selection.call(handlers[idx].callback);\n\t        }\n\t      }\n\n\t      handlers = this._handlers[eventName + ':transition'];\n\n\t      if (handlers && handlers.length) {\n\t        selection = selection.transition();\n\t        for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n\t          selection._chart = handlers[tidx].chart || this._base._chart;\n\t          selection.call(handlers[tidx].callback);\n\t        }\n\t      }\n\t\t\t}\n\t\t}\n\t}\n\n\tvar __layer = Layer;\n\n\tclass Chart {\n\t  constructor(selection) {\n\t    this.base = selection; // Container for chart @type {d3.selection}.\n\t      this.hasDrawn = false; // Has this chart been drawn at lease once?\n\n\t      function baseExtend(dst, objs) {\n\t        function isObject(value) { return value !== null && typeof value === 'object';}\n\t        function isFunction(value) {return typeof value === 'function';}\n\t        for (var i = 0, ii = objs.length; i < ii; ++i) {\n\t          var obj = objs[i];\n\t          if (!isObject(obj) && !isFunction(obj)) {\n\t            continue;\n\t          }\n\n\t          var keys = Object.keys(obj);\n\t          for (var j = 0, jj = keys.length; j < jj; j++) {\n\t            var key = keys[j];\n\t            var src = obj[key];\n\t            dst[key] = src;\n\t          }\n\t        }\n\t        return dst;\n\t      }\n\n\t      this.merge = {\n\t        configs: function(){\n\t          var merged = baseExtend({}, arguments);\n\t          this.config(merged);\n\t          return merged;\n\t        },\n\t        accessors: function(){\n\t          var merged = baseExtend({}, arguments);\n\t          this.accessor(merged);\n\t          return merged;\n\t        },\n\t      };\n\n\t      // exposed properties\n\t      this.configs = new Map();\n\n\t      // private\n\t      this._layers = new Map();\n\t      this._attached = new Map();\n\t      this._events = new Map();\n\t      this._accessors = new Map();\n\t  }\n\n\t  /**\n\t   * A \"hook\" method that you may define to modify input data before it is used\n\t   * to draw the chart's layers and attachments. This method will be used by all\n\t   * sub-classes.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {Array} data Input data provided to @link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  transform(data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that you may define to choose which mutation of the input\n\t   * data is sent to which of the attached charts (by name). This method will\n\t   * be used by all sub-classes. This only applies to charts that use the\n\t   * {@link Chart#attach} method.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n\t   * @param {Array} data Input data provided to {@link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  demux(name, data) { return data; }\n\n\t  preUpdate() {}\n\t  postUpdate() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code before\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  preDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  postDraw() {}\n\n\t  /**\n\t   * Remove a layer from the chart.\n\t   *\n\t   * @param {String} name The name of the layer to remove.\n\t   * @returns {Layer} The layer removed by this operation.\n\t   */\n\t  unlayer(name) {\n\t    var layer = this.layer(name);\n\n\t    this._layers.delete(name);\n\t    delete layer._chart;\n\n\t    return layer;\n\t  }\n\n\t  /**\n\t   * Interact with the chart's {@link Layer|layers}.\n\t   *\n\t   * If only a `name` is provided, simply return the layer registered to that\n\t   * name (if any).\n\t   *\n\t   * If a `name` and `selection` are provided, treat the `selection` as a\n\t   * previously-created layer and attach it to the chart with the specified\n\t   * `name`.\n\t   *\n\t   * If all three arguments are specified, initialize a new {@link Layer} using\n\t   * the specified `selection` as a base passing along the specified `options`.\n\t   *\n\t   * The {@link Layer.draw} method of attached layers will be invoked\n\t   * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t   * data (optionally modified by the chart's {@link Chart#transform} method.\n\t   *\n\t   * @param {String} name Name of the layer to attach or retrieve.\n\t   * @param {d3.selection|Layer} [selection] The layer's base or a\n\t   *        previously-created {@link Layer}.\n\t   * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t   *        constructor}\n\t   *\n\t   * @returns {Layer}\n\t   */\n\t  layer(name, selection, options) {\n\t    var _Chart = this;\n\t    var _layer;\n\n\t    if (arguments.length === 1) {\n\t      return this._layers.get(name);\n\t    }\n\n\t    // we are reattaching a previous layer, which the\n\t    // selection argument is now set to.\n\t    if (arguments.length === 2) {\n\n\t      if (typeof selection.draw === 'function') {\n\t        selection._chart = this;\n\t        this._layers.set(name, selection);\n\t        return this._layers.get(name);\n\n\t      } else {\n\t        assert(false, 'When reattaching a layer, the second argument '+\n\t          'must be a d3.chart layer');\n\t      }\n\t    }\n\n\t    _layer = new __layer(selection, options);\n\n\t    this._layers.set(name, _layer);\n\n\t    selection._chart = this;\n\n\t    _layer.remove = function () {\n\t      _Chart._layers.delete(name);\n\t      return this;\n\t    };\n\n\t    return _layer;\n\t  }\n\n\t  /**\n\t   * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t   * method will be invoked whenever the containing chart's `draw` method is\n\t   * invoked.\n\t   *\n\t   * @param {String} attachmentName Name of the attachment\n\t   * @param {Chart} [chart] koto to register as a mix in of this chart. When\n\t   *        unspecified, this method will return the attachment previously\n\t   *        registered with the specified `attachmentName` (if any).\n\t   *\n\t   * @returns {Chart} Reference to this chart (chainable).\n\t   */\n\t  attach(attachmentName, chart) {\n\t    if (arguments.length === 1) {\n\t      return this._attached.get(attachmentName);\n\t    }\n\n\t    this._attached.set(attachmentName, chart);\n\t    return chart;\n\t  }\n\n\t  /**\n\t   * Update the chart's representation in the DOM, drawing all of its layers and\n\t   * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t   *\n\t   * Note: The first time you call this method, the property `hasDrawn` will be\n\t   * set to true. This is helpful if you want to only run some code on the first\n\t   * time the chart is drawn.\n\t   *\n\t   * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t   *        this cart's {@link Layer|layers} (if any) and the {@link\n\t   *        Chart#draw|draw method} of this chart's attachments (if any).\n\t   */\n\t  draw(rawData) {\n\n\t    var layer, attachmentData;\n\n\t    var data = this.transform(rawData);\n\n\t    this.preDraw(data);\n\n\t    for (layer of this._layers.values()) {\n\t      layer.draw(data);\n\t    }\n\n\t    for (let [attachmentName, attachment] of this._attached.entries()) {\n\t      attachmentData = this.demux ? this.demux(attachmentName, data) : data;\n\t      attachment.draw(attachmentData);\n\t    }\n\n\t    this.hasDrawn = true;\n\n\t    this.postDraw(data);\n\t  }\n\n\t  reDraw(rawData) {\n\t    var layer, reAttachmentData;\n\n\t    var data = this.transform(rawData);\n\n\t    this.preUpdate(data);\n\n\t    for (layer of this._layers.values()) {\n\t      layer.draw(data);\n\t    }\n\n\t    for (let [reAttachmentName, reAttachment] of this._attached.entries()) {\n\t      reAttachmentData = this.demux ? this.demux(reAttachmentName, data) : data;\n\t      reAttachment.draw(reAttachmentData);\n\t    }\n\n\t    this.postUpdate(data);\n\t  }\n\n\t  /**\n\t   * Function invoked with the context specified when the handler was bound (via\n\t   * {@link Chart#on} {@link Chart#once}).\n\t   *\n\t   * @callback ChartEventHandler\n\t   * @param {...*} arguments Invoked with the arguments passed to {@link\n\t   *         Chart#trigger}\n\t   */\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. See {@link\n\t   * Chart#once} to subscribe a callback function to an event for one occurence.\n\t   *\n\t   * @externalExample {runnable} chart-on\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  on(name, callback, context) {\n\t    var events;\n\t    if (this._events.has(name)) {\n\t      events = this._events.get(name);\n\t    } else {\n\t      events = new Set();\n\t    }\n\n\t    events.add({\n\t      callback: callback,\n\t      context: context || this,\n\t      _chart: this\n\t    });\n\n\t    this._events.set(name, events);\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. This\n\t   * function will be invoked at the next occurance of the event and immediately\n\t   * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t   * event indefinitely.\n\t   *\n\t   * @externalExample {runnable} chart-once\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable)\n\t   */\n\t  once(name, callback, context) {\n\t    var self = this;\n\t    var _once = function() {\n\t      self.off(name, _once);\n\t      callback.apply(this, arguments);\n\t    };\n\t    return this.on(name, _once, context);\n\t  }\n\n\t  /**\n\t   * Unsubscribe one or more callback functions from an event triggered on the\n\t   * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t   * When only a `name` is specified, all handlers subscribed to that event will\n\t   * be unsubscribed. When a `name` and `callback` are specified, only that\n\t   * function will be unsubscribed from that event. When a `name` and `context`\n\t   * are specified (but `callback` is omitted), all events bound to the given\n\t   * event with the given context will be unsubscribed.\n\t   *\n\t   * @externalExample {runnable} chart-off\n\t   *\n\t   * @param {String} [name] Name of the event to be unsubscribed\n\t   * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t   * @param {Object} [context] Contexts to be unsubscribe\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  off(name, callback, context) {\n\n\t    // remove all events\n\t    if (arguments.length === 0) {\n\t      this._events.clear();\n\t      return this;\n\t    }\n\n\t    // remove all events for a specific name\n\t    if (arguments.length === 1) {\n\t      if (this._events.has(name)) {\n\t        this._events.get(name).clear();\n\t      }\n\t      return this;\n\t    }\n\n\t    // remove all events that match whatever combination of name, context\n\t    // and callback.\n\n\t    this._events.get(name).forEach((event, clone, map) => {\n\t      if ((callback && callback === clone.callback) ||\n\t          (context && context === clone.context)) {\n\t        map.delete(event);\n\t      }\n\t    });\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Publish an event on this chart with the given `name`.\n\t   *\n\t   * @externalExample {runnable} chart-trigger\n\t   *\n\t   * @param {String} name Name of the event to publish\n\t   * @param {...*} arguments Values with which to invoke the registered\n\t   *        callbacks.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  trigger(name, ...args) {\n\t    if (this._events.has(name)) {\n\t      this._events.get(name).forEach((event) => {\n\t        event.callback.call(event.context, ...args);\n\t      });\n\t    }\n\t    return this;\n\t  }\n\t  /**\n\t   * Get and set chart options (or configs)\n\t   *\n\t   * @param  {mixed} nameOrObject name of item getting or setting\n\t   *                              or its an object with key value pairs.\n\t   * @param  {mixed} value the value for config item witha that name.\n\t   * @return {mixed} if getting, its the value. if setting it is the chart instance.\n\t   */\n\t  config(nameOrObject, value) {\n\t    var key;\n\t    var definition;\n\n\t    if (arguments.length === 0) {\n\t      return this.configs;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof nameOrObject === 'object') {\n\t        for (key in nameOrObject) {\n\t          if(this.configs.has(key)) {\n\t            definition = this.configs.get(key);\n\t            definition.value = nameOrObject[key];\n\t            this.configs.set(key, definition); // redundant?\n\t          } else {\n\t            console.warn(`config with name ${nameOrObject} is not defined.`);\n\t          }\n\t        }\n\t        return this;\n\t      }\n\t      assert(this.configs.has(nameOrObject), `${nameOrObject} is not a valid option.`);\n\t      return this.configs.get(nameOrObject).value;\n\t    }\n\n\t    if(arguments.length === 2) {\n\t      if(this.configs.has(nameOrObject)) {\n\t        definition = this.configs.get(nameOrObject);\n\t        definition.value = value;\n\t        this.configs.set(nameOrObject, definition);\n\t      } else {\n\t        console.warn(`config with name ${nameOrObject} is not defined.`);\n\t      }\n\t      return this;\n\t    }\n\t  }\n\n\t  /**\n\t   * This will get or set any of the chart's accessors.\n\t   *\n\t   * @param  {String or Object} item If string, it will return the function for that accessor item.\n\t   *                                 If object, it will update that accessor with set function.\n\t   * @param  {function} [value] The function to update accessor item with.\n\t   * @return {object} The chart to preserve chainability.\n\t   */\n\t  accessor (item, value) {\n\t    var key;\n\t    if (arguments.length === 0) {\n\t      return this._accessors;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof item === 'string') {\n\t        assert(this._accessors.has(item), `${item} is not a valid accessor.`);\n\t        return this._accessors.get(item);\n\t      } else {\n\t        for (key in item) {\n\t          this._accessors.set(key, item[key]);\n\t        }\n\t      }\n\t    } else {\n\t      this._accessors.set(item, value);\n\t    }\n\t    return this;\n\t  }\n\t}\n\n\tvar _chart = Chart;\n\n\tassert(d3, 'd3 js is required.');\n\n\tvar koto = {};\n\tkoto.Base = _chart;\n\n\tvar index = koto;\n\n\treturn index;\n\n}));\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.koto = factory()\n}(this, function () { 'use strict';\n\n\t/**\n\t * Simple Assertion function\n\t * @param  {anything} test    Anything that will evaluate to true of false.\n\t * @param  {string} message The error message to send if `test` is false\n\t */\n\tfunction kotoAssert(test, message) {\n\t  if (test) {\n\t    return;\n\t  }\n\t  throw new Error(`[koto] ${message}`);\n\t}\n\n\tvar assert = kotoAssert;\n\n\tclass Layer {\n\t  constructor(base, options) {\n\t    this._base = base;\n\t    this._handlers = {};\n\t    this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n\t    if (options) {\n\t      // Set layer methods (required)\n\t      this.dataBind = options.dataBind;\n\t      this.insert = options.insert;\n\n\t      // Bind events (optional)\n\t      if ('events' in options) {\n\t        for (let eventName in options.events) {\n\t          this.on(eventName, options.events[eventName]);\n\t        }\n\t      }\n\t    }\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t\t *\n\t\t * @param {Array} data Value passed to {@link Layer#draw}\n\t\t */\n\t\tdataBind() {\n\t\t\tassert(false, 'Layers must specify a dataBind method.');\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t\t * Layer instances.\n\t\t */\n\t\tinsert() {\n\t\t\tassert(false, 'Layers must specify an `insert` method.');\n\t\t}\n\n\t\t/**\n\t\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t\t * for more details on lifecycle events.\n\t\t *\n\t\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t\t *        subscribe.\n\t\t * @param {Function} handler Callback function\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\ton(eventName, handler, options) {\n\t\t\toptions = options || {};\n\n\t\t\tassert(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!(eventName in this._handlers)) {\n\t\t\t\tthis._handlers[eventName] = [];\n\t\t\t}\n\t\t\tthis._handlers[eventName].push({\n\t\t\t\tcallback: handler,\n\t\t\t\tchart: options.chart || null\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t\t * supplied, remove *all* handlers from the event.\n\t\t *\n\t\t * @param {String} eventName Identifier for event from which to remove\n\t\t *        unsubscribe\n\t\t * @param {Function} handler Callback to remove from the specified event\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\toff(eventName, handler) {\n\t\t\tvar handlers = this._handlers[eventName];\n\t\t\tvar idx;\n\n\t\t\tassert(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!handlers) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (arguments.length === 1) {\n\t\t\t\thandlers.length = 0;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\t\thandlers.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Render the layer according to the input data: Bind the data to the layer\n\t\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t\t *\n\t\t * - update\n\t\t * - update:transition\n\t\t * - enter\n\t\t * - enter:transition\n\t\t * - exit\n\t\t * - exit:transition\n\t\t *\n\t\t * @param {Array} data Data to drive the rendering.\n\t\t */\n\t\tdraw(data) {\n\t\t\tvar bound,\n\t\t\t\tentering,\n\t\t\t\tevents,\n\t\t\t\tselection,\n\t\t\t\tmethod,\n\t\t\t\thandlers,\n\t\t\t\teventName,\n\t      idx,\n\t      len,\n\t      tidx,\n\t      tlen;\n\n\t\t\tbound = this.dataBind.call(this._base, data);\n\n\t\t\tassert(bound instanceof d3.selection,\n\t      'Invalid selection defined by `Layer#dataBind` method.');\n\t\t\tassert(bound.enter, 'Layer selection not properly bound.');\n\n\t\t\tentering = bound.enter();\n\t\t\tentering._chart = this._base._chart;\n\n\t\t\tevents = [\n\t\t\t\t{\n\t\t\t\t\tname: 'update',\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'enter',\n\t\t\t\t\tselection: entering,\n\t\t\t\t\tmethod: this.insert\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'merge',\n\t\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t\t// when triggering the `enter` event.\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'exit',\n\t\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t\t// `d3.selection.exit`.\n\t\t\t\t\tselection: bound,\n\t\t\t\t\tmethod: bound.exit\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\t\teventName = events[i].name;\n\t\t\t\tselection = events[i].selection;\n\t\t\t\tmethod = events[i].method;\n\n\t\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t\t// deferred until just prior to handler invocation.\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tselection = method.call(selection);\n\t\t\t\t}\n\n\t\t\t\tif (selection.empty()) {\n\t        continue;\n\t\t\t\t}\n\n\t\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t\t// compatability.\n\n\t\t\t\tassert(selection && selection instanceof d3.selection,\n\t        `Invalid selection defined for ${eventName} lifecycle event.`);\n\n\t\t\t\thandlers = this._handlers[eventName];\n\n\t      if (handlers) {\n\t        for (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t          // Attach a reference to the parent chart so the selection\"s\n\t          // `chart` method will function correctly.\n\t          selection._chart = handlers[idx].chart || this._base._chart;\n\t          selection.call(handlers[idx].callback);\n\t        }\n\t      }\n\n\t      handlers = this._handlers[eventName + ':transition'];\n\n\t      if (handlers && handlers.length) {\n\t        selection = selection.transition();\n\t        for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n\t          selection._chart = handlers[tidx].chart || this._base._chart;\n\t          selection.call(handlers[tidx].callback);\n\t        }\n\t      }\n\t\t\t}\n\t\t}\n\t}\n\n\tvar __layer = Layer;\n\n\tclass Chart {\n\t  constructor(selection) {\n\t    this.base = selection; // Container for chart @type {d3.selection}.\n\t      this.hasDrawn = false; // Has this chart been drawn at lease once?\n\n\t      function baseExtend(dst, objs) {\n\t        function isObject(value) { return value !== null && typeof value === 'object';}\n\t        function isFunction(value) {return typeof value === 'function';}\n\t        for (var i = 0, ii = objs.length; i < ii; ++i) {\n\t          var obj = objs[i];\n\t          if (!isObject(obj) && !isFunction(obj)) {\n\t            continue;\n\t          }\n\n\t          var keys = Object.keys(obj);\n\t          for (var j = 0, jj = keys.length; j < jj; j++) {\n\t            var key = keys[j];\n\t            var src = obj[key];\n\t            dst[key] = src;\n\t          }\n\t        }\n\t        return dst;\n\t      }\n\n\t      this.merge = {\n\t        configs: function(){\n\t          var merged = baseExtend({}, arguments);\n\t          this.config(merged);\n\t          return merged;\n\t        },\n\t        accessors: function(){\n\t          var merged = baseExtend({}, arguments);\n\t          this.accessor(merged);\n\t          return merged;\n\t        },\n\t      };\n\n\t      // exposed properties\n\t      this.configs = new Map();\n\n\t      // private\n\t      this._layers = new Map();\n\t      this._attached = new Map();\n\t      this._events = new Map();\n\t      this._accessors = new Map();\n\t  }\n\n\t  /**\n\t   * A \"hook\" method that you may define to modify input data before it is used\n\t   * to draw the chart's layers and attachments. This method will be used by all\n\t   * sub-classes.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {Array} data Input data provided to @link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  transform(data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that you may define to choose which mutation of the input\n\t   * data is sent to which of the attached charts (by name). This method will\n\t   * be used by all sub-classes. This only applies to charts that use the\n\t   * {@link Chart#attach} method.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n\t   * @param {Array} data Input data provided to {@link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  demux(name, data) { return data; }\n\n\t  preUpdate() {}\n\t  postUpdate() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code before\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  preDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  postDraw() {}\n\n\t  /**\n\t   * Remove a layer from the chart.\n\t   *\n\t   * @param {String} name The name of the layer to remove.\n\t   * @returns {Layer} The layer removed by this operation.\n\t   */\n\t  unlayer(name) {\n\t    var layer = this.layer(name);\n\n\t    this._layers.delete(name);\n\t    delete layer._chart;\n\n\t    return layer;\n\t  }\n\n\t  /**\n\t   * Interact with the chart's {@link Layer|layers}.\n\t   *\n\t   * If only a `name` is provided, simply return the layer registered to that\n\t   * name (if any).\n\t   *\n\t   * If a `name` and `selection` are provided, treat the `selection` as a\n\t   * previously-created layer and attach it to the chart with the specified\n\t   * `name`.\n\t   *\n\t   * If all three arguments are specified, initialize a new {@link Layer} using\n\t   * the specified `selection` as a base passing along the specified `options`.\n\t   *\n\t   * The {@link Layer.draw} method of attached layers will be invoked\n\t   * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t   * data (optionally modified by the chart's {@link Chart#transform} method.\n\t   *\n\t   * @param {String} name Name of the layer to attach or retrieve.\n\t   * @param {d3.selection|Layer} [selection] The layer's base or a\n\t   *        previously-created {@link Layer}.\n\t   * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t   *        constructor}\n\t   *\n\t   * @returns {Layer}\n\t   */\n\t  layer(name, selection, options) {\n\t    var _Chart = this;\n\t    var _layer;\n\n\t    if (arguments.length === 1) {\n\t      return this._layers.get(name);\n\t    }\n\n\t    // we are reattaching a previous layer, which the\n\t    // selection argument is now set to.\n\t    if (arguments.length === 2) {\n\n\t      if (typeof selection.draw === 'function') {\n\t        selection._chart = this;\n\t        this._layers.set(name, selection);\n\t        return this._layers.get(name);\n\n\t      } else {\n\t        assert(false, 'When reattaching a layer, the second argument '+\n\t          'must be a d3.chart layer');\n\t      }\n\t    }\n\n\t    _layer = new __layer(selection, options);\n\n\t    this._layers.set(name, _layer);\n\n\t    selection._chart = this;\n\n\t    _layer.remove = function () {\n\t      _Chart._layers.delete(name);\n\t      return this;\n\t    };\n\n\t    return _layer;\n\t  }\n\n\t  /**\n\t   * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t   * method will be invoked whenever the containing chart's `draw` method is\n\t   * invoked.\n\t   *\n\t   * @param {String} attachmentName Name of the attachment\n\t   * @param {Chart} [chart] koto to register as a mix in of this chart. When\n\t   *        unspecified, this method will return the attachment previously\n\t   *        registered with the specified `attachmentName` (if any).\n\t   *\n\t   * @returns {Chart} Reference to this chart (chainable).\n\t   */\n\t  attach(attachmentName, chart) {\n\t    if (arguments.length === 1) {\n\t      return this._attached.get(attachmentName);\n\t    }\n\n\t    this._attached.set(attachmentName, chart);\n\t    return chart;\n\t  }\n\n\t  /**\n\t   * Update the chart's representation in the DOM, drawing all of its layers and\n\t   * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t   *\n\t   * Note: The first time you call this method, the property `hasDrawn` will be\n\t   * set to true. This is helpful if you want to only run some code on the first\n\t   * time the chart is drawn.\n\t   *\n\t   * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t   *        this cart's {@link Layer|layers} (if any) and the {@link\n\t   *        Chart#draw|draw method} of this chart's attachments (if any).\n\t   */\n\t  draw(rawData) {\n\n\t    var layer, attachmentData;\n\n\t    var data = this.transform(rawData);\n\n\t    this.preDraw(data);\n\n\t    for (layer of this._layers.values()) {\n\t      layer.draw(data);\n\t    }\n\n\t    for (let [attachmentName, attachment] of this._attached.entries()) {\n\t      attachmentData = this.demux ? this.demux(attachmentName, data) : data;\n\t      attachment.draw(attachmentData);\n\t    }\n\n\t    this.hasDrawn = true;\n\n\t    this.postDraw(data);\n\t  }\n\n\t  reDraw(rawData) {\n\t    var layer, reAttachmentData;\n\n\t    var data = this.transform(rawData);\n\n\t    this.preUpdate(data);\n\n\t    for (layer of this._layers.values()) {\n\t      layer.draw(data);\n\t    }\n\n\t    for (let [reAttachmentName, reAttachment] of this._attached.entries()) {\n\t      reAttachmentData = this.demux ? this.demux(reAttachmentName, data) : data;\n\t      reAttachment.draw(reAttachmentData);\n\t    }\n\n\t    this.postUpdate(data);\n\t  }\n\n\t  /**\n\t   * Function invoked with the context specified when the handler was bound (via\n\t   * {@link Chart#on} {@link Chart#once}).\n\t   *\n\t   * @callback ChartEventHandler\n\t   * @param {...*} arguments Invoked with the arguments passed to {@link\n\t   *         Chart#trigger}\n\t   */\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. See {@link\n\t   * Chart#once} to subscribe a callback function to an event for one occurence.\n\t   *\n\t   * @externalExample {runnable} chart-on\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  on(name, callback, context) {\n\t    var events;\n\t    if (this._events.has(name)) {\n\t      events = this._events.get(name);\n\t    } else {\n\t      events = new Set();\n\t    }\n\n\t    events.add({\n\t      callback: callback,\n\t      context: context || this,\n\t      _chart: this\n\t    });\n\n\t    this._events.set(name, events);\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. This\n\t   * function will be invoked at the next occurance of the event and immediately\n\t   * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t   * event indefinitely.\n\t   *\n\t   * @externalExample {runnable} chart-once\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable)\n\t   */\n\t  once(name, callback, context) {\n\t    var self = this;\n\t    var _once = function() {\n\t      self.off(name, _once);\n\t      callback.apply(this, arguments);\n\t    };\n\t    return this.on(name, _once, context);\n\t  }\n\n\t  /**\n\t   * Unsubscribe one or more callback functions from an event triggered on the\n\t   * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t   * When only a `name` is specified, all handlers subscribed to that event will\n\t   * be unsubscribed. When a `name` and `callback` are specified, only that\n\t   * function will be unsubscribed from that event. When a `name` and `context`\n\t   * are specified (but `callback` is omitted), all events bound to the given\n\t   * event with the given context will be unsubscribed.\n\t   *\n\t   * @externalExample {runnable} chart-off\n\t   *\n\t   * @param {String} [name] Name of the event to be unsubscribed\n\t   * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t   * @param {Object} [context] Contexts to be unsubscribe\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  off(name, callback, context) {\n\n\t    // remove all events\n\t    if (arguments.length === 0) {\n\t      this._events.clear();\n\t      return this;\n\t    }\n\n\t    // remove all events for a specific name\n\t    if (arguments.length === 1) {\n\t      if (this._events.has(name)) {\n\t        this._events.get(name).clear();\n\t      }\n\t      return this;\n\t    }\n\n\t    // remove all events that match whatever combination of name, context\n\t    // and callback.\n\n\t    this._events.get(name).forEach((event, clone, map) => {\n\t      if ((callback && callback === clone.callback) ||\n\t          (context && context === clone.context)) {\n\t        map.delete(event);\n\t      }\n\t    });\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Publish an event on this chart with the given `name`.\n\t   *\n\t   * @externalExample {runnable} chart-trigger\n\t   *\n\t   * @param {String} name Name of the event to publish\n\t   * @param {...*} arguments Values with which to invoke the registered\n\t   *        callbacks.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  trigger(name, ...args) {\n\t    if (this._events.has(name)) {\n\t      this._events.get(name).forEach((event) => {\n\t        event.callback.call(event.context, ...args);\n\t      });\n\t    }\n\t    return this;\n\t  }\n\t  /**\n\t   * Get and set chart options (or configs)\n\t   *\n\t   * @param  {mixed} nameOrObject name of item getting or setting\n\t   *                              or its an object with key value pairs.\n\t   * @param  {mixed} value the value for config item witha that name.\n\t   * @return {mixed} if getting, its the value. if setting it is the chart instance.\n\t   */\n\t  config(nameOrObject, value) {\n\t    var key;\n\t    var definition;\n\n\t    if (arguments.length === 0) {\n\t      return this.configs;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof nameOrObject === 'object') {\n\t        for (key in nameOrObject) {\n\t          if(this.configs.has(key)) {\n\t            definition = this.configs.get(key);\n\t            definition.value = nameOrObject[key];\n\t            this.configs.set(key, definition); // redundant?\n\t          } else {\n\t            console.warn(`config with name ${nameOrObject} is not defined.`);\n\t          }\n\t        }\n\t        return this;\n\t      }\n\t      assert(this.configs.has(nameOrObject), `${nameOrObject} is not a valid option.`);\n\t      return this.configs.get(nameOrObject).value;\n\t    }\n\n\t    if(arguments.length === 2) {\n\t      if(this.configs.has(nameOrObject)) {\n\t        definition = this.configs.get(nameOrObject);\n\t        definition.value = value;\n\t        this.configs.set(nameOrObject, definition);\n\t      } else {\n\t        console.warn(`config with name ${nameOrObject} is not defined.`);\n\t      }\n\t      return this;\n\t    }\n\t  }\n\n\t  /**\n\t   * This will get or set any of the chart's accessors.\n\t   *\n\t   * @param  {String or Object} item If string, it will return the function for that accessor item.\n\t   *                                 If object, it will update that accessor with set function.\n\t   * @param  {function} [value] The function to update accessor item with.\n\t   * @return {object} The chart to preserve chainability.\n\t   */\n\t  accessor (item, value) {\n\t    var key;\n\t    if (arguments.length === 0) {\n\t      return this._accessors;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof item === 'string') {\n\t        assert(this._accessors.has(item), `${item} is not a valid accessor.`);\n\t        return this._accessors.get(item);\n\t      } else {\n\t        for (key in item) {\n\t          this._accessors.set(key, item[key]);\n\t        }\n\t      }\n\t    } else {\n\t      this._accessors.set(item, value);\n\t    }\n\t    return this;\n\t  }\n\t}\n\n\tvar _chart = Chart;\n\n\tassert(d3, 'd3 js is required.');\n\n\tvar koto = {};\n\tkoto.Base = _chart;\n\n\tvar index = koto;\n\n\treturn index;\n\n}));\n"]}