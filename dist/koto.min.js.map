{"version":3,"file":"koto.js","sources":["koto.js","/source/koto.js"],"names":["global","factory","exports","module","require","define","amd","Koto","d3","this","kotoAssert","test","message","Error","assert_js","Layer","base","options","_base","_handlers","_lifecycleRe","dataBind","insert","eventName","events","on","prototype","handler","push","callback","chart","off","idx","handlers","arguments","length","splice","draw","data","endall","transition","n","size","each","apply","promiseCallback","resolve","selection","call","bound","entering","method","len","tidx","tlen","promises","enter","_chart","name","exit","i","l","empty","Promise","promise","all","layer_js","Chart","baseExtend","dst","maps","setDst","value","key","set","ii","map","forEach","hasDrawn","merge","configs","merged","bind","accessors","Map","_layers","_attached","_events","c","config","a","accessor","transform","demux","preDraw","postDraw","postTransition","unlayer","layer","_layer","_Chart","get","remove","attach","attachmentName","rawData","attachmentData","trigger","_iterator","values","_isArray","Array","isArray","_i","Symbol","iterator","_iterator2","entries","_isArray2","_i2","_ref2","attachment","then","context","has","Set","add","once","self","_once","clear","event","clone","args","_len","_key","_event$callback","concat","nameOrObject","setPercentage","calcultePerecentage","arr","initialValue","min","Math","definition","constrain","percentage","hasOwnProperty","setter","console","warn","getter","item","extend","init","_ref","initialize"],"mappings":"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","sourceRoot":"/source/","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('d3')) :\n\ttypeof define === 'function' && define.amd ? define(['d3'], factory) :\n\tglobal.Koto = factory(global.d3)\n}(this, function (d3) { 'use strict';\n\n\t/**\n\t * Simple Assertion function\n\t * @param  {anything} test    Anything that will evaluate to true of false.\n\t * @param  {string} message The error message to send if `test` is false\n\t */\n\tfunction kotoAssert(test, message) {\n\t  if (test) {\n\t    return;\n\t  }\n\t  throw new Error(`[koto] ${message}`);\n\t}\n\n\tvar assert_js = kotoAssert;\n\n\tclass Layer {\n\t  constructor(base, options) {\n\t    this._base = base;\n\t    this._handlers = {};\n\t    this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n\t    if (options) {\n\t      // Set layer methods (required)\n\t      this.dataBind = options.dataBind;\n\t      this.insert = options.insert;\n\n\t      // Bind events (optional)\n\t      if ('events' in options) {\n\t        for (var eventName in options.events) {\n\t          this.on(eventName, options.events[eventName]);\n\t        }\n\t      }\n\t    }\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t\t *\n\t\t * @param {Array} data Value passed to {@link Layer#draw}\n\t\t */\n\t\tdataBind() {\n\t\t\tassert_js(false, 'Layers must specify a dataBind method.');\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t\t * Layer instances.\n\t\t */\n\t\tinsert() {\n\t\t\tassert_js(false, 'Layers must specify an `insert` method.');\n\t\t}\n\n\t\t/**\n\t\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t\t * for more details on lifecycle events.\n\t\t *\n\t\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t\t *        subscribe.\n\t\t * @param {Function} handler Callback function\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\ton(eventName, handler, options) {\n\t\t\toptions = options || {};\n\n\t\t\tassert_js(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!(eventName in this._handlers)) {\n\t\t\t\tthis._handlers[eventName] = [];\n\t\t\t}\n\t\t\tthis._handlers[eventName].push({\n\t\t\t\tcallback: handler,\n\t\t\t\tchart: options.chart || null\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t\t * supplied, remove *all* handlers from the event.\n\t\t *\n\t\t * @param {String} eventName Identifier for event from which to remove\n\t\t *        unsubscribe\n\t\t * @param {Function} handler Callback to remove from the specified event\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\toff(eventName, handler) {\n\t\t\tvar handlers = this._handlers[eventName];\n\t\t\tvar idx;\n\n\t\t\tassert_js(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!handlers) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (arguments.length === 1) {\n\t\t\t\thandlers.length = 0;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\t\thandlers.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Render the layer according to the input data: Bind the data to the layer\n\t\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t\t *\n\t\t * - update\n\t\t * - update:transition\n\t\t * - enter\n\t\t * - enter:transition\n\t\t * - exit\n\t\t * - exit:transition\n\t\t *\n\t\t * @param {Array} data Data to drive the rendering.\n\t\t */\n\t\tdraw(data) {\n\t\t\tvar bound,\n\t\t\t\tentering,\n\t\t\t\tevents,\n\t\t\t\tselection,\n\t\t\t\tmethod,\n\t\t\t\thandlers,\n\t\t\t\teventName,\n\t      idx,\n\t      len,\n\t      tidx,\n\t      tlen,\n\t      promises = [];\n\n\t    function endall(transition, callback) {\n\t      var n = 0;\n\t      if (transition.size() === 0) {\n\t        callback();\n\t      } else {\n\t        transition\n\t          .each(function() {\n\t            ++n;\n\t          })\n\t          .each('interrupt.promise', function () {\n\t            callback.apply(this, arguments);\n\t          })\n\t          .each('end.promise', function () {\n\t            if (!--n) {\n\t              callback.apply(this, arguments);\n\t            }\n\t          });\n\t      }\n\t    }\n\n\t    function promiseCallback (resolve) {\n\t      selection.call(endall, function() {\n\t        resolve(true);\n\t      });\n\t    }\n\n\t\t\tbound = this.dataBind.call(this._base, data);\n\n\t\t\tassert_js(bound instanceof d3.selection,\n\t      'Invalid selection defined by `Layer#dataBind` method.');\n\t\t\tassert_js(bound.enter, 'Layer selection not properly bound.');\n\n\t\t\tentering = bound.enter();\n\t\t\tentering._chart = this._base._chart;\n\n\t\t\tevents = [\n\t\t\t\t{\n\t\t\t\t\tname: 'update',\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'enter',\n\t\t\t\t\tselection: entering,\n\t\t\t\t\tmethod: this.insert\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'merge',\n\t\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t\t// when triggering the `enter` event.\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'exit',\n\t\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t\t// `d3.selection.exit`.\n\t\t\t\t\tselection: bound,\n\t\t\t\t\tmethod: bound.exit\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\t\teventName = events[i].name;\n\t\t\t\tselection = events[i].selection;\n\t\t\t\tmethod = events[i].method;\n\n\t\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t\t// deferred until just prior to handler invocation.\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tselection = method.call(selection);\n\t\t\t\t}\n\n\t\t\t\tif (selection.empty()) {\n\t        continue;\n\t\t\t\t}\n\n\t\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t\t// compatability.\n\n\t\t\t\tassert_js(selection && selection instanceof d3.selection,\n\t        `Invalid selection defined for ${eventName} lifecycle event.`);\n\n\t\t\t\thandlers = this._handlers[eventName];\n\n\t      if (handlers) {\n\t        for (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t          // Attach a reference to the parent chart so the selection\"s\n\t          // `chart` method will function correctly.\n\t          selection._chart = handlers[idx].chart || this._base._chart;\n\t          selection.call(handlers[idx].callback);\n\t        }\n\t      }\n\n\t      handlers = this._handlers[eventName + ':transition'];\n\n\t      if (handlers && handlers.length) {\n\t        selection = selection.transition();\n\t        for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n\t          selection._chart = handlers[tidx].chart || this._base._chart;\n\t          selection.call(handlers[tidx].callback);\n\t          promises.push(new Promise(promiseCallback));\n\t        }\n\t      }\n\t      this.promise = Promise.all(promises);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar layer_js = Layer;\n\n\tassert_js(d3, 'd3 js is required.');\n\n\t/**\n\t * Create a koto chart\n\t *\n\t * @constructor\n\t *\n\t * @param {d3.selection} selection The chart's \"base\" DOM node. This should\n\t *        contain any nodes that the chart generates.\n\t */\n\tclass Chart {\n\t  constructor(selection) {\n\t    this.base = selection; // Container for chart @type {d3.selection}.\n\t    this.hasDrawn = false; // Has this chart been drawn at lease once?\n\n\t    function baseExtend(dst, maps) {\n\t      var setDst = function (value, key) {\n\t          dst.set(key, value);\n\t      };\n\t      for (var i = 0, ii = maps.length; i < ii; ++i) {\n\t        var map = maps[i];\n\t        map.forEach(setDst);\n\t      }\n\t      return dst;\n\t    }\n\n\t    this.merge = {\n\t      configs: function(){\n\t        var merged = baseExtend(this.configs, arguments);\n\t        return merged;\n\t      }.bind(this),\n\t      accessors: function(){\n\t        var merged = baseExtend(this.accessors, arguments);\n\t        return merged;\n\t      }.bind(this)\n\t    };\n\n\t    // exposed properties\n\t    this.configs = new Map();\n\t    this.accessors = new Map();\n\t    this.promise = null;\n\n\t    // private\n\t    this._layers = new Map();\n\t    this._attached = new Map();\n\t    this._events = new Map();\n\n\t    // alias\n\t    this.c = this.config;\n\t    this.a = this.accessor;\n\t  }\n\n\t  /**\n\t   * A \"hook\" method that you may define to modify input data before it is used\n\t   * to draw the chart's layers and attachments. This method will be used by all\n\t   * sub-classes.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {Array} data Input data provided to @link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  transform(data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that you may define to choose which mutation of the input\n\t   * data is sent to which of the attached charts (by name). This method will\n\t   * be used by all sub-classes. This only applies to charts that use the\n\t   * {@link Chart#attach} method.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n\t   * @param {Array} data Input data provided to {@link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  demux(name, data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code before\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * Note 2: a `postDraw` event is also fired when appropriate;\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  preDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   */\n\t  postDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw} is called AND after all transitions for all layers\n\t   * and attached charts have been completed. This will run everytime\n\t   * {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * Note 2: a `postTransition` event is also fired when appropriate;\n\t   *\n\t   * @param  {[type]} data\n\t   */\n\t  postTransition() {}\n\n\t  /**\n\t   * Remove a layer from the chart.\n\t   *\n\t   * @param {String} name The name of the layer to remove.\n\t   * @returns {Layer} The layer removed by this operation.\n\t   */\n\t  unlayer(name) {\n\t    var layer = this.layer(name);\n\n\t    this._layers.delete(name);\n\t    delete layer._chart;\n\n\t    return layer;\n\t  }\n\n\t  /**\n\t   * Interact with the chart's {@link Layer|layers}.\n\t   *\n\t   * If only a `name` is provided, simply return the layer registered to that\n\t   * name (if any).\n\t   *\n\t   * If a `name` and `selection` are provided, treat the `selection` as a\n\t   * previously-created layer and attach it to the chart with the specified\n\t   * `name`.\n\t   *\n\t   * If all three arguments are specified, initialize a new {@link Layer} using\n\t   * the specified `selection` as a base passing along the specified `options`.\n\t   *\n\t   * The {@link Layer.draw} method of attached layers will be invoked\n\t   * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t   * data (optionally modified by the chart's {@link Chart#transform} method.\n\t   *\n\t   * @param {String} name Name of the layer to attach or retrieve.\n\t   * @param {d3.selection|Layer} [selection] The layer's base or a\n\t   *        previously-created {@link Layer}.\n\t   * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t   *        constructor}\n\t   *\n\t   * @returns {Layer}\n\t   */\n\t  layer(name, selection, options) {\n\t    var _Chart = this;\n\t    var _layer;\n\n\t    if (arguments.length === 1) {\n\t      return this._layers.get(name);\n\t    }\n\n\t    // we are reattaching a previous layer, which the\n\t    // selection argument is now set to.\n\t    if (arguments.length === 2) {\n\n\t      if (selection instanceof layer_js) {\n\t        selection._chart = this;\n\t        this._layers.set(name, selection);\n\t        return this._layers.get(name);\n\n\t      } else {\n\t        assert_js(false, 'When reattaching a layer, the second argument must be a koto layer');\n\t      }\n\t    }\n\n\t    selection._chart = this;\n\n\t    _layer = new layer_js(selection, options);\n\n\t    _layer.remove = function () {\n\t      _Chart._layers.delete(name);\n\t      return this;\n\t    };\n\n\t    this._layers.set(name, _layer);\n\n\t    return _layer;\n\t  }\n\n\t  /**\n\t   * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t   * method will be invoked whenever the containing chart's `draw` method is\n\t   * invoked.\n\t   *\n\t   * @param {String} attachmentName Name of the attachment\n\t   * @param {Chart} [chart] koto to register as a mix in of this chart. When\n\t   *        unspecified, this method will return the attachment previously\n\t   *        registered with the specified `attachmentName` (if any).\n\t   *\n\t   * @returns {Chart} Reference to this chart (chainable).\n\t   */\n\t  attach(attachmentName, chart) {\n\t    if (arguments.length === 1) {\n\t      return this._attached.get(attachmentName);\n\t    }\n\n\t    this._attached.set(attachmentName, chart);\n\t    return chart;\n\t  }\n\n\t  /**\n\t   * Update the chart's representation in the DOM, drawing all of its layers and\n\t   * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t   *\n\t   * Note: The first time you call this method, the property `hasDrawn` will be\n\t   * set to true. This is helpful if you want to only run some code on the first\n\t   * time the chart is drawn.\n\t   *\n\t   * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t   *        this cart's {@link Layer|layers} (if any) and the {@link\n\t   *        Chart#draw|draw method} of this chart's attachments (if any).\n\t   */\n\t  draw(rawData) {\n\t    var layer, attachmentData, promises = [];\n\n\t    var data = this.transform(rawData);\n\n\t    this.preDraw(data);\n\t    this.trigger('preDraw', data);\n\n\t    for (layer of this._layers.values()) {\n\t      layer.draw(data);\n\t      promises.push(layer.promise);\n\t    }\n\n\t    for (var [attachmentName, attachment] of this._attached.entries()) {\n\t      attachmentData = this.demux ? this.demux(attachmentName, data) : data;\n\t      attachment.draw(attachmentData);\n\t      promises.push(attachment.promise);\n\t    }\n\n\t    this.hasDrawn = true;\n\n\t    this.promise = Promise.all(promises);\n\n\t    this.postDraw();\n\t    this.trigger('postDraw', data);\n\n\t    this.promise.then(function () {\n\t      this.postTransition(data);\n\t      this.trigger('postTransition', data);\n\t    }.bind(this));\n\t  }\n\n\t  /**\n\t   * Function invoked with the context specified when the handler was bound (via\n\t   * {@link Chart#on} {@link Chart#once}).\n\t   *\n\t   * @callback ChartEventHandler\n\t   * @param {...*} arguments Invoked with the arguments passed to {@link\n\t   *         Chart#trigger}\n\t   */\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. See {@link\n\t   * Chart#once} to subscribe a callback function to an event for one occurence.\n\t   *\n\t   * @externalExample {runnable} chart-on\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  on(name, callback, context) {\n\t    var events;\n\t    if (this._events.has(name)) {\n\t      events = this._events.get(name);\n\t    } else {\n\t      events = new Set();\n\t    }\n\n\t    events.add({\n\t      callback: callback,\n\t      context: context || this,\n\t      _chart: this\n\t    });\n\n\t    this._events.set(name, events);\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. This\n\t   * function will be invoked at the next occurance of the event and immediately\n\t   * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t   * event indefinitely.\n\t   *\n\t   * @externalExample {runnable} chart-once\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable)\n\t   */\n\t  once(name, callback, context) {\n\t    var self = this;\n\t    var _once = function() {\n\t      self.off(name, _once);\n\t      callback.apply(this, arguments);\n\t    };\n\t    return this.on(name, _once, context);\n\t  }\n\n\t  /**\n\t   * Unsubscribe one or more callback functions from an event triggered on the\n\t   * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t   * When only a `name` is specified, all handlers subscribed to that event will\n\t   * be unsubscribed. When a `name` and `callback` are specified, only that\n\t   * function will be unsubscribed from that event. When a `name` and `context`\n\t   * are specified (but `callback` is omitted), all events bound to the given\n\t   * event with the given context will be unsubscribed.\n\t   *\n\t   * @externalExample {runnable} chart-off\n\t   *\n\t   * @param {String} [name] Name of the event to be unsubscribed\n\t   * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t   * @param {Object} [context] Contexts to be unsubscribe\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  off(name, callback, context) {\n\n\t    // remove all events\n\t    if (arguments.length === 0) {\n\t      this._events.clear();\n\t      return this;\n\t    }\n\n\t    // remove all events for a specific name\n\t    if (arguments.length === 1) {\n\t      if (this._events.has(name)) {\n\t        this._events.get(name).clear();\n\t      }\n\t      return this;\n\t    }\n\n\t    // remove all events that match whatever combination of name, context\n\t    // and callback.\n\n\t    this._events.get(name).forEach((event, clone, map) => {\n\t      if ((callback && callback === clone.callback) ||\n\t          (context && context === clone.context)) {\n\t        map.delete(event);\n\t      }\n\t    });\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Publish an event on this chart with the given `name`.\n\t   *\n\t   * @externalExample {runnable} chart-trigger\n\t   *\n\t   * @param {String} name Name of the event to publish\n\t   * @param {...*} arguments Values with which to invoke the registered\n\t   *        callbacks.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  trigger(name, ...args) {\n\t    if (this._events.has(name)) {\n\t      this._events.get(name).forEach((event) => {\n\t        event.callback.call(event.context, ...args);\n\t      });\n\t    }\n\t    return this;\n\t  }\n\t  /**\n\t   * Get and set chart options (or configs)\n\t   *\n\t   * @param  {mixed} nameOrObject name of item getting or setting\n\t   *                              or its an object with key value pairs.\n\t   * @param  {mixed} value the value for config item witha that name.\n\t   * @return {mixed} if getting, its the value. if setting it is the chart instance.\n\t   */\n\t  config(nameOrObject, value) {\n\t    var key;\n\t    var definition;\n\t    var _Chart = this;\n\n\t    function setPercentage () {\n\t      function calcultePerecentage (arr, initialValue) {\n\t        var min = Math.min.call(null, arr.map(function (name) { return _Chart.config(name); }));\n\t        return initialValue / min;\n\t      }\n\n\t      if (definition.constrain === true) {\n\t        definition.percentage = calcultePerecentage(['width', 'height'], definition.value);\n\t      } else if (Array.isArray(definition.constrain)) {\n\t        definition.percentage = calcultePerecentage(definition.constrain, definition.value);\n\t      } else {\n\t        definition.percentage = calcultePerecentage([definition.constrain], definition.value);\n\t      }\n\t    }\n\n\t    if (arguments.length === 0) {\n\t      return this.configs;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof nameOrObject === 'object') {\n\t        for (key in nameOrObject) {\n\t          if(this.configs.has(key)) {\n\t            definition = this.configs.get(key);\n\t            if (definition.hasOwnProperty('setter')) {\n\t              definition.value = definition.setter.call(definition, nameOrObject[key]);\n\t            } else {\n\t              definition.value = nameOrObject[key];\n\t            }\n\t            if (definition.hasOwnProperty('constrain')) {\n\t              setPercentage();\n\t            }\n\t            this.configs.set(key, definition);\n\t          } else {\n\t            console.warn(`config with name ${nameOrObject} is not defined.`);\n\t          }\n\t        }\n\t        return this;\n\t      }\n\n\t      assert_js(this.configs.has(nameOrObject), `${nameOrObject} is not a valid option.`);\n\t      definition = this.configs.get(nameOrObject);\n\t      if (definition.hasOwnProperty('getter')) {\n\t        return definition.getter.call(definition);\n\t      }\n\t      return definition.value;\n\t    }\n\n\t    if(arguments.length === 2) {\n\t      if (this.configs.has(nameOrObject)) {\n\t        definition = this.configs.get(nameOrObject);\n\t        if (definition.hasOwnProperty('setter')) {\n\t          definition.value = definition.setter.call(definition, value);\n\t        } else {\n\t          definition.value = value;\n\t        }\n\t        if (definition.hasOwnProperty('constrain')) {\n\t          setPercentage();\n\t        }\n\t        this.configs.set(nameOrObject, definition);\n\t      } else {\n\t        console.warn(`config with name ${nameOrObject} is not defined.`);\n\t      }\n\t      return this;\n\t    }\n\t  }\n\n\t  /**\n\t   * This will get or set any of the chart's accessors.\n\t   *\n\t   * @param  {String or Object} item If string, it will return the function for that accessor item.\n\t   *                                 If object, it will update that accessor with set function.\n\t   * @param  {function} [value] The function to update accessor item with.\n\t   * @return {object} The chart to preserve chainability.\n\t   */\n\t  accessor (item, value) {\n\t    var key;\n\t    if (arguments.length === 0) {\n\t      return this.accessors;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof item === 'string') {\n\t        assert_js(this.accessors.has(item), `${item} is not a valid accessor.`);\n\t        return this.accessors.get(item);\n\t      } else {\n\t        for (key in item) {\n\t          this.accessors.set(key, item[key]);\n\t        }\n\t      }\n\t    } else {\n\t      this.accessors.set(item, value);\n\t    }\n\t    return this;\n\t  }\n\n\t  /**\n\t   * This will extend a chart by passing in an object of initialize function.\n\t   * @param  {Object || function} init Initialize function of object with initialize method.\n\t   * @return {Construtor}      Chart constructor\n\t   */\n\t  static extend(init) {\n\t    class chart extends this {\n\t      constructor(selection) {\n\t        var key;\n\t        super(selection);\n\n\t        if (typeof init === 'function') {\n\t          init.call(this);\n\t        } else {\n\t          for (key in init) {\n\t            this[key] = init[key];\n\t          }\n\t          this.initialize.call(this);\n\t        }\n\n\t      }\n\t    }\n\t    return chart;\n\t  }\n\t}\n\n\tvar _chart = Chart;\n\n\treturn _chart;\n\n}));\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('d3')) :\n\ttypeof define === 'function' && define.amd ? define(['d3'], factory) :\n\tglobal.Koto = factory(global.d3)\n}(this, function (d3) { 'use strict';\n\n\t/**\n\t * Simple Assertion function\n\t * @param  {anything} test    Anything that will evaluate to true of false.\n\t * @param  {string} message The error message to send if `test` is false\n\t */\n\tfunction kotoAssert(test, message) {\n\t  if (test) {\n\t    return;\n\t  }\n\t  throw new Error(`[koto] ${message}`);\n\t}\n\n\tvar assert_js = kotoAssert;\n\n\tclass Layer {\n\t  constructor(base, options) {\n\t    this._base = base;\n\t    this._handlers = {};\n\t    this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n\t    if (options) {\n\t      // Set layer methods (required)\n\t      this.dataBind = options.dataBind;\n\t      this.insert = options.insert;\n\n\t      // Bind events (optional)\n\t      if ('events' in options) {\n\t        for (var eventName in options.events) {\n\t          this.on(eventName, options.events[eventName]);\n\t        }\n\t      }\n\t    }\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t\t *\n\t\t * @param {Array} data Value passed to {@link Layer#draw}\n\t\t */\n\t\tdataBind() {\n\t\t\tassert_js(false, 'Layers must specify a dataBind method.');\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t\t * Layer instances.\n\t\t */\n\t\tinsert() {\n\t\t\tassert_js(false, 'Layers must specify an `insert` method.');\n\t\t}\n\n\t\t/**\n\t\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t\t * for more details on lifecycle events.\n\t\t *\n\t\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t\t *        subscribe.\n\t\t * @param {Function} handler Callback function\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\ton(eventName, handler, options) {\n\t\t\toptions = options || {};\n\n\t\t\tassert_js(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!(eventName in this._handlers)) {\n\t\t\t\tthis._handlers[eventName] = [];\n\t\t\t}\n\t\t\tthis._handlers[eventName].push({\n\t\t\t\tcallback: handler,\n\t\t\t\tchart: options.chart || null\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t\t * supplied, remove *all* handlers from the event.\n\t\t *\n\t\t * @param {String} eventName Identifier for event from which to remove\n\t\t *        unsubscribe\n\t\t * @param {Function} handler Callback to remove from the specified event\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\toff(eventName, handler) {\n\t\t\tvar handlers = this._handlers[eventName];\n\t\t\tvar idx;\n\n\t\t\tassert_js(this._lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!handlers) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (arguments.length === 1) {\n\t\t\t\thandlers.length = 0;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\t\thandlers.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Render the layer according to the input data: Bind the data to the layer\n\t\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t\t *\n\t\t * - update\n\t\t * - update:transition\n\t\t * - enter\n\t\t * - enter:transition\n\t\t * - exit\n\t\t * - exit:transition\n\t\t *\n\t\t * @param {Array} data Data to drive the rendering.\n\t\t */\n\t\tdraw(data) {\n\t\t\tvar bound,\n\t\t\t\tentering,\n\t\t\t\tevents,\n\t\t\t\tselection,\n\t\t\t\tmethod,\n\t\t\t\thandlers,\n\t\t\t\teventName,\n\t      idx,\n\t      len,\n\t      tidx,\n\t      tlen,\n\t      promises = [];\n\n\t    function endall(transition, callback) {\n\t      var n = 0;\n\t      if (transition.size() === 0) {\n\t        callback();\n\t      } else {\n\t        transition\n\t          .each(function() {\n\t            ++n;\n\t          })\n\t          .each('interrupt.promise', function () {\n\t            callback.apply(this, arguments);\n\t          })\n\t          .each('end.promise', function () {\n\t            if (!--n) {\n\t              callback.apply(this, arguments);\n\t            }\n\t          });\n\t      }\n\t    }\n\n\t    function promiseCallback (resolve) {\n\t      selection.call(endall, function() {\n\t        resolve(true);\n\t      });\n\t    }\n\n\t\t\tbound = this.dataBind.call(this._base, data);\n\n\t\t\tassert_js(bound instanceof d3.selection,\n\t      'Invalid selection defined by `Layer#dataBind` method.');\n\t\t\tassert_js(bound.enter, 'Layer selection not properly bound.');\n\n\t\t\tentering = bound.enter();\n\t\t\tentering._chart = this._base._chart;\n\n\t\t\tevents = [\n\t\t\t\t{\n\t\t\t\t\tname: 'update',\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'enter',\n\t\t\t\t\tselection: entering,\n\t\t\t\t\tmethod: this.insert\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'merge',\n\t\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t\t// when triggering the `enter` event.\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'exit',\n\t\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t\t// `d3.selection.exit`.\n\t\t\t\t\tselection: bound,\n\t\t\t\t\tmethod: bound.exit\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\t\teventName = events[i].name;\n\t\t\t\tselection = events[i].selection;\n\t\t\t\tmethod = events[i].method;\n\n\t\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t\t// deferred until just prior to handler invocation.\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tselection = method.call(selection);\n\t\t\t\t}\n\n\t\t\t\tif (selection.empty()) {\n\t        continue;\n\t\t\t\t}\n\n\t\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t\t// compatability.\n\n\t\t\t\tassert_js(selection && selection instanceof d3.selection,\n\t        `Invalid selection defined for ${eventName} lifecycle event.`);\n\n\t\t\t\thandlers = this._handlers[eventName];\n\n\t      if (handlers) {\n\t        for (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t          // Attach a reference to the parent chart so the selection\"s\n\t          // `chart` method will function correctly.\n\t          selection._chart = handlers[idx].chart || this._base._chart;\n\t          selection.call(handlers[idx].callback);\n\t        }\n\t      }\n\n\t      handlers = this._handlers[eventName + ':transition'];\n\n\t      if (handlers && handlers.length) {\n\t        selection = selection.transition();\n\t        for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n\t          selection._chart = handlers[tidx].chart || this._base._chart;\n\t          selection.call(handlers[tidx].callback);\n\t          promises.push(new Promise(promiseCallback));\n\t        }\n\t      }\n\t      this.promise = Promise.all(promises);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar layer_js = Layer;\n\n\tassert_js(d3, 'd3 js is required.');\n\n\t/**\n\t * Create a koto chart\n\t *\n\t * @constructor\n\t *\n\t * @param {d3.selection} selection The chart's \"base\" DOM node. This should\n\t *        contain any nodes that the chart generates.\n\t */\n\tclass Chart {\n\t  constructor(selection) {\n\t    this.base = selection; // Container for chart @type {d3.selection}.\n\t    this.hasDrawn = false; // Has this chart been drawn at lease once?\n\n\t    function baseExtend(dst, maps) {\n\t      var setDst = function (value, key) {\n\t          dst.set(key, value);\n\t      };\n\t      for (var i = 0, ii = maps.length; i < ii; ++i) {\n\t        var map = maps[i];\n\t        map.forEach(setDst);\n\t      }\n\t      return dst;\n\t    }\n\n\t    this.merge = {\n\t      configs: function(){\n\t        var merged = baseExtend(this.configs, arguments);\n\t        return merged;\n\t      }.bind(this),\n\t      accessors: function(){\n\t        var merged = baseExtend(this.accessors, arguments);\n\t        return merged;\n\t      }.bind(this)\n\t    };\n\n\t    // exposed properties\n\t    this.configs = new Map();\n\t    this.accessors = new Map();\n\t    this.promise = null;\n\n\t    // private\n\t    this._layers = new Map();\n\t    this._attached = new Map();\n\t    this._events = new Map();\n\n\t    // alias\n\t    this.c = this.config;\n\t    this.a = this.accessor;\n\t  }\n\n\t  /**\n\t   * A \"hook\" method that you may define to modify input data before it is used\n\t   * to draw the chart's layers and attachments. This method will be used by all\n\t   * sub-classes.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {Array} data Input data provided to @link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  transform(data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that you may define to choose which mutation of the input\n\t   * data is sent to which of the attached charts (by name). This method will\n\t   * be used by all sub-classes. This only applies to charts that use the\n\t   * {@link Chart#attach} method.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n\t   * @param {Array} data Input data provided to {@link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  demux(name, data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code before\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * Note 2: a `postDraw` event is also fired when appropriate;\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  preDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   */\n\t  postDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw} is called AND after all transitions for all layers\n\t   * and attached charts have been completed. This will run everytime\n\t   * {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * Note 2: a `postTransition` event is also fired when appropriate;\n\t   *\n\t   * @param  {[type]} data\n\t   */\n\t  postTransition() {}\n\n\t  /**\n\t   * Remove a layer from the chart.\n\t   *\n\t   * @param {String} name The name of the layer to remove.\n\t   * @returns {Layer} The layer removed by this operation.\n\t   */\n\t  unlayer(name) {\n\t    var layer = this.layer(name);\n\n\t    this._layers.delete(name);\n\t    delete layer._chart;\n\n\t    return layer;\n\t  }\n\n\t  /**\n\t   * Interact with the chart's {@link Layer|layers}.\n\t   *\n\t   * If only a `name` is provided, simply return the layer registered to that\n\t   * name (if any).\n\t   *\n\t   * If a `name` and `selection` are provided, treat the `selection` as a\n\t   * previously-created layer and attach it to the chart with the specified\n\t   * `name`.\n\t   *\n\t   * If all three arguments are specified, initialize a new {@link Layer} using\n\t   * the specified `selection` as a base passing along the specified `options`.\n\t   *\n\t   * The {@link Layer.draw} method of attached layers will be invoked\n\t   * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t   * data (optionally modified by the chart's {@link Chart#transform} method.\n\t   *\n\t   * @param {String} name Name of the layer to attach or retrieve.\n\t   * @param {d3.selection|Layer} [selection] The layer's base or a\n\t   *        previously-created {@link Layer}.\n\t   * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t   *        constructor}\n\t   *\n\t   * @returns {Layer}\n\t   */\n\t  layer(name, selection, options) {\n\t    var _Chart = this;\n\t    var _layer;\n\n\t    if (arguments.length === 1) {\n\t      return this._layers.get(name);\n\t    }\n\n\t    // we are reattaching a previous layer, which the\n\t    // selection argument is now set to.\n\t    if (arguments.length === 2) {\n\n\t      if (selection instanceof layer_js) {\n\t        selection._chart = this;\n\t        this._layers.set(name, selection);\n\t        return this._layers.get(name);\n\n\t      } else {\n\t        assert_js(false, 'When reattaching a layer, the second argument must be a koto layer');\n\t      }\n\t    }\n\n\t    selection._chart = this;\n\n\t    _layer = new layer_js(selection, options);\n\n\t    _layer.remove = function () {\n\t      _Chart._layers.delete(name);\n\t      return this;\n\t    };\n\n\t    this._layers.set(name, _layer);\n\n\t    return _layer;\n\t  }\n\n\t  /**\n\t   * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t   * method will be invoked whenever the containing chart's `draw` method is\n\t   * invoked.\n\t   *\n\t   * @param {String} attachmentName Name of the attachment\n\t   * @param {Chart} [chart] koto to register as a mix in of this chart. When\n\t   *        unspecified, this method will return the attachment previously\n\t   *        registered with the specified `attachmentName` (if any).\n\t   *\n\t   * @returns {Chart} Reference to this chart (chainable).\n\t   */\n\t  attach(attachmentName, chart) {\n\t    if (arguments.length === 1) {\n\t      return this._attached.get(attachmentName);\n\t    }\n\n\t    this._attached.set(attachmentName, chart);\n\t    return chart;\n\t  }\n\n\t  /**\n\t   * Update the chart's representation in the DOM, drawing all of its layers and\n\t   * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t   *\n\t   * Note: The first time you call this method, the property `hasDrawn` will be\n\t   * set to true. This is helpful if you want to only run some code on the first\n\t   * time the chart is drawn.\n\t   *\n\t   * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t   *        this cart's {@link Layer|layers} (if any) and the {@link\n\t   *        Chart#draw|draw method} of this chart's attachments (if any).\n\t   */\n\t  draw(rawData) {\n\t    var layer, attachmentData, promises = [];\n\n\t    var data = this.transform(rawData);\n\n\t    this.preDraw(data);\n\t    this.trigger('preDraw', data);\n\n\t    for (layer of this._layers.values()) {\n\t      layer.draw(data);\n\t      promises.push(layer.promise);\n\t    }\n\n\t    for (var [attachmentName, attachment] of this._attached.entries()) {\n\t      attachmentData = this.demux ? this.demux(attachmentName, data) : data;\n\t      attachment.draw(attachmentData);\n\t      promises.push(attachment.promise);\n\t    }\n\n\t    this.hasDrawn = true;\n\n\t    this.promise = Promise.all(promises);\n\n\t    this.postDraw();\n\t    this.trigger('postDraw', data);\n\n\t    this.promise.then(function () {\n\t      this.postTransition(data);\n\t      this.trigger('postTransition', data);\n\t    }.bind(this));\n\t  }\n\n\t  /**\n\t   * Function invoked with the context specified when the handler was bound (via\n\t   * {@link Chart#on} {@link Chart#once}).\n\t   *\n\t   * @callback ChartEventHandler\n\t   * @param {...*} arguments Invoked with the arguments passed to {@link\n\t   *         Chart#trigger}\n\t   */\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. See {@link\n\t   * Chart#once} to subscribe a callback function to an event for one occurence.\n\t   *\n\t   * @externalExample {runnable} chart-on\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  on(name, callback, context) {\n\t    var events;\n\t    if (this._events.has(name)) {\n\t      events = this._events.get(name);\n\t    } else {\n\t      events = new Set();\n\t    }\n\n\t    events.add({\n\t      callback: callback,\n\t      context: context || this,\n\t      _chart: this\n\t    });\n\n\t    this._events.set(name, events);\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. This\n\t   * function will be invoked at the next occurance of the event and immediately\n\t   * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t   * event indefinitely.\n\t   *\n\t   * @externalExample {runnable} chart-once\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable)\n\t   */\n\t  once(name, callback, context) {\n\t    var self = this;\n\t    var _once = function() {\n\t      self.off(name, _once);\n\t      callback.apply(this, arguments);\n\t    };\n\t    return this.on(name, _once, context);\n\t  }\n\n\t  /**\n\t   * Unsubscribe one or more callback functions from an event triggered on the\n\t   * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t   * When only a `name` is specified, all handlers subscribed to that event will\n\t   * be unsubscribed. When a `name` and `callback` are specified, only that\n\t   * function will be unsubscribed from that event. When a `name` and `context`\n\t   * are specified (but `callback` is omitted), all events bound to the given\n\t   * event with the given context will be unsubscribed.\n\t   *\n\t   * @externalExample {runnable} chart-off\n\t   *\n\t   * @param {String} [name] Name of the event to be unsubscribed\n\t   * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t   * @param {Object} [context] Contexts to be unsubscribe\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  off(name, callback, context) {\n\n\t    // remove all events\n\t    if (arguments.length === 0) {\n\t      this._events.clear();\n\t      return this;\n\t    }\n\n\t    // remove all events for a specific name\n\t    if (arguments.length === 1) {\n\t      if (this._events.has(name)) {\n\t        this._events.get(name).clear();\n\t      }\n\t      return this;\n\t    }\n\n\t    // remove all events that match whatever combination of name, context\n\t    // and callback.\n\n\t    this._events.get(name).forEach((event, clone, map) => {\n\t      if ((callback && callback === clone.callback) ||\n\t          (context && context === clone.context)) {\n\t        map.delete(event);\n\t      }\n\t    });\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Publish an event on this chart with the given `name`.\n\t   *\n\t   * @externalExample {runnable} chart-trigger\n\t   *\n\t   * @param {String} name Name of the event to publish\n\t   * @param {...*} arguments Values with which to invoke the registered\n\t   *        callbacks.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  trigger(name, ...args) {\n\t    if (this._events.has(name)) {\n\t      this._events.get(name).forEach((event) => {\n\t        event.callback.call(event.context, ...args);\n\t      });\n\t    }\n\t    return this;\n\t  }\n\t  /**\n\t   * Get and set chart options (or configs)\n\t   *\n\t   * @param  {mixed} nameOrObject name of item getting or setting\n\t   *                              or its an object with key value pairs.\n\t   * @param  {mixed} value the value for config item witha that name.\n\t   * @return {mixed} if getting, its the value. if setting it is the chart instance.\n\t   */\n\t  config(nameOrObject, value) {\n\t    var key;\n\t    var definition;\n\t    var _Chart = this;\n\n\t    function setPercentage () {\n\t      function calcultePerecentage (arr, initialValue) {\n\t        var min = Math.min.call(null, arr.map(function (name) { return _Chart.config(name); }));\n\t        return initialValue / min;\n\t      }\n\n\t      if (definition.constrain === true) {\n\t        definition.percentage = calcultePerecentage(['width', 'height'], definition.value);\n\t      } else if (Array.isArray(definition.constrain)) {\n\t        definition.percentage = calcultePerecentage(definition.constrain, definition.value);\n\t      } else {\n\t        definition.percentage = calcultePerecentage([definition.constrain], definition.value);\n\t      }\n\t    }\n\n\t    if (arguments.length === 0) {\n\t      return this.configs;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof nameOrObject === 'object') {\n\t        for (key in nameOrObject) {\n\t          if(this.configs.has(key)) {\n\t            definition = this.configs.get(key);\n\t            if (definition.hasOwnProperty('setter')) {\n\t              definition.value = definition.setter.call(definition, nameOrObject[key]);\n\t            } else {\n\t              definition.value = nameOrObject[key];\n\t            }\n\t            if (definition.hasOwnProperty('constrain')) {\n\t              setPercentage();\n\t            }\n\t            this.configs.set(key, definition);\n\t          } else {\n\t            console.warn(`config with name ${nameOrObject} is not defined.`);\n\t          }\n\t        }\n\t        return this;\n\t      }\n\n\t      assert_js(this.configs.has(nameOrObject), `${nameOrObject} is not a valid option.`);\n\t      definition = this.configs.get(nameOrObject);\n\t      if (definition.hasOwnProperty('getter')) {\n\t        return definition.getter.call(definition);\n\t      }\n\t      return definition.value;\n\t    }\n\n\t    if(arguments.length === 2) {\n\t      if (this.configs.has(nameOrObject)) {\n\t        definition = this.configs.get(nameOrObject);\n\t        if (definition.hasOwnProperty('setter')) {\n\t          definition.value = definition.setter.call(definition, value);\n\t        } else {\n\t          definition.value = value;\n\t        }\n\t        if (definition.hasOwnProperty('constrain')) {\n\t          setPercentage();\n\t        }\n\t        this.configs.set(nameOrObject, definition);\n\t      } else {\n\t        console.warn(`config with name ${nameOrObject} is not defined.`);\n\t      }\n\t      return this;\n\t    }\n\t  }\n\n\t  /**\n\t   * This will get or set any of the chart's accessors.\n\t   *\n\t   * @param  {String or Object} item If string, it will return the function for that accessor item.\n\t   *                                 If object, it will update that accessor with set function.\n\t   * @param  {function} [value] The function to update accessor item with.\n\t   * @return {object} The chart to preserve chainability.\n\t   */\n\t  accessor (item, value) {\n\t    var key;\n\t    if (arguments.length === 0) {\n\t      return this.accessors;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof item === 'string') {\n\t        assert_js(this.accessors.has(item), `${item} is not a valid accessor.`);\n\t        return this.accessors.get(item);\n\t      } else {\n\t        for (key in item) {\n\t          this.accessors.set(key, item[key]);\n\t        }\n\t      }\n\t    } else {\n\t      this.accessors.set(item, value);\n\t    }\n\t    return this;\n\t  }\n\n\t  /**\n\t   * This will extend a chart by passing in an object of initialize function.\n\t   * @param  {Object || function} init Initialize function of object with initialize method.\n\t   * @return {Construtor}      Chart constructor\n\t   */\n\t  static extend(init) {\n\t    class chart extends this {\n\t      constructor(selection) {\n\t        var key;\n\t        super(selection);\n\n\t        if (typeof init === 'function') {\n\t          init.call(this);\n\t        } else {\n\t          for (key in init) {\n\t            this[key] = init[key];\n\t          }\n\t          this.initialize.call(this);\n\t        }\n\n\t      }\n\t    }\n\t    return chart;\n\t  }\n\t}\n\n\tvar _chart = Chart;\n\n\treturn _chart;\n\n}));\n"]}