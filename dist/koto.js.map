{"version":3,"sources":["koto.js"],"names":[],"mappings":";;;;AAAA,AAAC,CAAA,UAAU,MAAM,EAAE,OAAO,EAAE;AAC1B,SAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,WAAW,GAAG,MAAM,CAAC,OAAO,GAAG,OAAO,EAAE,GACzF,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC,GAC5D,MAAM,CAAC,IAAI,GAAG,OAAO,EAAE,CAAA;CACxB,CAAA,CAAC,IAAI,EAAE,YAAY;AAAE,cAAY,CAAC;;;;;;;AAOjC,WAAS,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE;AACjC,QAAI,IAAI,EAAE;AACR,aAAO;KACR;AACD,UAAM,IAAI,KAAK,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC;GACtC;;MAEK,KAAK;;;;;;;;AAQC,aARN,KAAK,CAQE,SAAS;4BARhB,KAAK;;AAST,UAAI,CAAC,IAAI,GAAG,SAAS,CAAC;AACpB,UAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;;;AAGxB,UAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAClB,UAAI,CAAC,SAAS,GAAG,EAAE,CAAC;AACpB,UAAI,CAAC,OAAO,GAAG,EAAE,CAAC;KAClB;;yBAhBI,KAAK;AA+BV,eAAS;;;;;;;;;;;;;;;eAAA,mBAAC,IAAI,EAAE;AAAE,iBAAO,IAAI,CAAC;SAAE;;;;AAiBhC,WAAK;;;;;;;;;;;;;;;;;eAAA,eAAC,IAAI,EAAE,IAAI,EAAE;AAAE,iBAAO,IAAI,CAAC;SAAE;;;;AAalC,aAAO;;;;;;;;;;;;;eAAA,mBAAG,EAAE;;;;AAaZ,cAAQ;;;;;;;;;;;;;eAAA,oBAAG,EAAE;;;;AAQb,aAAO;;;;;;;;eAAA,iBAAC,IAAI,EAAE;AACb,cAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;;AAE7B,iBAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAC1B,iBAAO,KAAK,CAAC,MAAM,CAAC;;AAEpB,iBAAO,KAAK,CAAC;SACb;;;;AA2BD,WAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;eAAA,eAAC,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE;AAC/B,cAAI,KAAK,CAAC;;AAEV,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3B,mBAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;WAC1B;;;;AAID,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAE3B,gBAAI,OAAO,SAAS,CAAC,IAAI,KAAK,UAAU,EAAE;AACzC,uBAAS,CAAC,MAAM,GAAG,IAAI,CAAC;AACxB,kBAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;AAC/B,qBAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;aAE1B,MAAM;AACN,wBAAU,CAAC,KAAK,EAAE,gDAAgD,GACjE,0BAA0B,CAAC,CAAC;aAC7B;WACD;;AAED,eAAK,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;;AAEjC,cAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;;AAE3B,mBAAS,CAAC,MAAM,GAAG,IAAI,CAAC;;AAExB,iBAAO,KAAK,CAAC;SACb;;;;AAcD,YAAM;;;;;;;;;;;;;;eAAA,gBAAC,cAAc,EAAE,KAAK,EAAE;AAC7B,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3B,mBAAO,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;WACtC;;AAED,cAAI,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,KAAK,CAAC;AACvC,iBAAO,KAAK,CAAC;SACb;;;;AAcD,UAAI;;;;;;;;;;;;;;eAAA,cAAC,OAAO,EAAE;AAEb,cAAI,SAAS,EAAE,cAAc,EAAE,cAAc,CAAC;;AAE9C,cAAI,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;;AAEjC,cAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;AAErB,eAAK,SAAS,IAAI,IAAI,CAAC,OAAO,EAAE;AAC/B,gBAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;WACnC;;AAED,eAAK,cAAc,IAAI,IAAI,CAAC,SAAS,EAAE;AACtC,gBAAI,IAAI,CAAC,KAAK,EAAE;AACf,4BAAc,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;aAClD,MAAM;AACN,4BAAc,GAAG,IAAI,CAAC;aACtB;AACD,gBAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;WACpD;;AAEC,cAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;;AAErB,cAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACtB;;;;AAyBD,QAAE;;;;;;;;;;;;;;;;;;;;;;;;;eAAA,YAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC3B,cAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAA,AAAC,CAAC;AAC7D,gBAAM,CAAC,IAAI,CAAC;AACX,oBAAQ,EAAE,QAAQ;AAClB,mBAAO,EAAE,OAAO,IAAI,IAAI;AACxB,kBAAM,EAAE,IAAI;WACZ,CAAC,CAAC;AACH,iBAAO,IAAI,CAAC;SACZ;;;;AAkBD,UAAI;;;;;;;;;;;;;;;;;;eAAA,cAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC7B,cAAI,IAAI,GAAG,IAAI,CAAC;AAChB,cAAI,IAAI,GAAG,YAAW;AACrB,gBAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACrB,oBAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;WAChC,CAAC;AACF,iBAAO,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;SACpC;;;;AAmBD,SAAG;;;;;;;;;;;;;;;;;;;eAAA,aAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC5B,cAAI,KAAK,EAAE,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;;;AAGlC,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3B,iBAAK,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;AAC1B,kBAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;aAC9B;AACD,mBAAO,IAAI,CAAC;WACZ;;;AAGD,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3B,kBAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAC5B,gBAAI,MAAM,EAAE;AACX,oBAAM,CAAC,MAAM,GAAG,CAAC,CAAC;aAClB;AACD,mBAAO,IAAI,CAAC;WACZ;;;;AAID,eAAK,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAClD,eAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAClC,aAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AACb,kBAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACzB,aAAC,GAAG,MAAM,CAAC,MAAM,CAAC;AAClB,mBAAO,CAAC,EAAE,EAAE;AACX,mBAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAClB,kBAAI,AAAC,QAAQ,IAAI,QAAQ,KAAK,KAAK,CAAC,QAAQ,IACzC,OAAO,IAAI,OAAO,KAAK,KAAK,CAAC,OAAO,AAAC,EAAE;AACzC,sBAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;eACpB;aACD;WACD;;AAED,iBAAO,IAAI,CAAC;SACZ;;;;AAaD,aAAO;;;;;;;;;;;;;eAAA,iBAAC,IAAI,EAAE;AACb,cAAI,IAAI,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AACpD,cAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAChC,cAAI,CAAC,EAAE,EAAE,CAAC;;AAEV,cAAI,MAAM,KAAK,SAAS,EAAE;AACzB,iBAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,gBAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACf,gBAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;aACpC;WACD;;AAED,iBAAO,IAAI,CAAC;SACZ;;;;;;WAxVI,KAAK;;;AA2VX,MAAI,WAAW,GAAG,2CAA2C,CAAC;;;;;;;;;AAS9D,WAAS,gBAAgB,CAAE,SAAS,EAAE,QAAQ,EAAE;AAC/C,QAAI,GAAG,EAAE,GAAG,CAAC;AACb,SAAK,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE;;;AAGtD,eAAS,CAAC,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AAC5D,eAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;KACvC;GACD;;;;;;;;;;;;;MAaK,KAAK;AACC,aADN,KAAK,CACE,IAAI;4BADX,KAAK;;AAET,UAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,UAAI,CAAC,SAAS,GAAG,EAAE,CAAC;KACpB;;yBAJI,KAAK;AAYV,cAAQ;;;;;;;;eAAA,oBAAG;AACV,oBAAU,CAAC,KAAK,EAAE,wCAAwC,CAAC,CAAC;SAC5D;;;;AAOD,YAAM;;;;;;;eAAA,kBAAG;AACR,oBAAU,CAAC,KAAK,EAAE,yCAAyC,CAAC,CAAC;SAC7D;;;;AAaD,QAAE;;;;;;;;;;;;;eAAA,YAAC,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE;AAC/B,iBAAO,GAAG,OAAO,IAAI,EAAE,CAAC;;AAExB,oBAAU,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,EACrC,4EAA8E,CAAC,CAAC;;AAEjF,cAAI,EAAE,SAAS,IAAI,IAAI,CAAC,SAAS,CAAA,AAAC,EAAE;AACnC,gBAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;WAC/B;AACD,cAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC;AAC9B,oBAAQ,EAAE,OAAO;AACjB,iBAAK,EAAE,OAAO,CAAC,KAAK,IAAI,IAAI;WAC5B,CAAC,CAAC;AACH,iBAAO,IAAI,CAAC,KAAK,CAAC;SAClB;;;;AAYD,SAAG;;;;;;;;;;;;eAAA,aAAC,SAAS,EAAE,OAAO,EAAE;AAEvB,cAAI,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;AACzC,cAAI,GAAG,CAAC;;AAER,oBAAU,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,EACrC,4EAA8E,CAAC,CAAC;;AAEjF,cAAI,CAAC,QAAQ,EAAE;AACd,mBAAO,IAAI,CAAC,KAAK,CAAC;WAClB;;AAED,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3B,oBAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;AACpB,mBAAO,IAAI,CAAC,KAAK,CAAC;WAClB;;AAED,eAAK,GAAG,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE;AAChD,gBAAI,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,KAAK,OAAO,EAAE;AACvC,sBAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aACxB;WACD;AACD,iBAAO,IAAI,CAAC,KAAK,CAAC;SAClB;;;;AAiBD,UAAI;;;;;;;;;;;;;;;;;eAAA,cAAC,IAAI,EAAE;AACV,cAAI,KAAK,EACR,QAAQ,EACR,MAAM,EACN,SAAS,EACT,MAAM,EACN,QAAQ,EACR,kBAAkB,EAClB,SAAS,CAAC;;AAEX,eAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;;AAE7C,oBAAU,CAAC,KAAK,YAAY,EAAE,CAAC,SAAS,EACtC,uDAAuD,CAAC,CAAC;AAC3D,oBAAU,CAAC,KAAK,CAAC,KAAK,EAAE,qCAAqC,CAAC,CAAC;;AAE/D,kBAAQ,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;AACzB,kBAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;;AAEpC,gBAAM,GAAG,CACR;AACC,gBAAI,EAAE,QAAQ;AACd,qBAAS,EAAE,KAAK;WAChB,EACD;AACC,gBAAI,EAAE,OAAO;AACb,qBAAS,EAAE,QAAQ;AACnB,kBAAM,EAAE,IAAI,CAAC,MAAM;WACnB,EACD;AACC,gBAAI,EAAE,OAAO;;;;;AAKb,qBAAS,EAAE,KAAK;WAChB,EACD;AACC,gBAAI,EAAE,MAAM;;;;;AAKZ,qBAAS,EAAE,KAAK;AAChB,kBAAM,EAAE,KAAK,CAAC,IAAI;WAClB,CACD,CAAC;;AAEF,eAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;AAC9C,qBAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AAC3B,qBAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AAChC,kBAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;;;;AAI1B,gBAAI,OAAO,MAAM,KAAK,UAAU,EAAE;AACjC,uBAAS,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACnC;;AAED,gBAAI,SAAS,CAAC,KAAK,EAAE,EAAE;AACtB,uBAAS;aACT;;;;;;AAMD,sBAAU,CAAC,SAAS,IAAI,SAAS,YAAY,EAAE,CAAC,SAAS,EACvD,6DAA6D,CAAC,CAAC;;AAEjE,oBAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;;AAErC,gBAAI,QAAQ,EAAE;AACb,8BAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;aACjD;;AAED,8BAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,aAAa,CAAC,CAAC;;AAE/D,gBAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,EAAE;AAChC,uBAAS,GAAG,SAAS,CAAC,UAAU,EAAE,CAAC;AACnC,8BAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,kBAAkB,CAAC,CAAC;aAC3D;WACD;SACD;;;;;;WAzLI,KAAK;;;MA4LL,OAAO;AACD,aADN,OAAO;wCACG,OAAO;AAAP,eAAO;;;4BADjB,OAAO;;AAEX,UAAI,CAAC,EAAE,GAAG,CAAC;AACX,UAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;;AAE3B,WAAK,CAAC,GAAC,CAAC,EAAE,CAAC,GAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAChC,aAAI,GAAG,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;AACtB,cAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;SACrC;OACD;KAED;;yBAXI,OAAO;AAiBZ,SAAG;;;;;;eAAA,aAAC,IAAI,EAAE;AACT,oBAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,0BAA0B,CAAC,CAAC;AAC5D,iBAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SAC3B;;;;AASD,SAAG;;;;;;;;;eAAA,aAAC,YAAY,EAAE,MAAM,EAAE;AACzB,cAAI,GAAG,CAAC;AACR,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3B,iBAAK,GAAG,IAAI,YAAY,EAAE;AACzB,wBAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,0BAA0B,CAAC,CAAC;AAC3D,kBAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;aACvC;WACD,MAAM;AACN,sBAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE,0BAA0B,CAAC,CAAC;AACpE,gBAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;WAC1C;AACD,iBAAO,IAAI,CAAC;SACZ;;;;AAQD,YAAM;;;;;;;;eAAA,gBAAC,IAAI,EAAC;AACX,iBAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC3B,iBAAO,IAAI,CAAC;SACZ;;;;;;WApDI,OAAO;;;AAuDb,YAAU,CAAC,EAAE,EAAE,mBAAmB,CAAC,CAAC;;;;;;;;;;MAU9B,IAAI;AACG,aADP,IAAI,CACI,OAAO,EAAE,KAAK,EAAE,KAAK;4BAD7B,IAAI;;AAEN,UAAI,CAAC,SAAS,GAAG,EAAE,CAAC;;AAEpB,UAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AACvB,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACpB;;yBAPG,IAAI;AA2BR,WAAK;;;;;;;;;;;;;;;;;;;;eAAA,eAAC,IAAI,EAAE,OAAO,EAAE;AACnB,cAAI,SAAS,CAAC;AACd,cAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC1B,mBAAO,IAAI,CAAC,SAAS,CAAC;WACvB,MAAM,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AACjC,qBAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AACjC,qBAAS,WAAQ,GAAG,UAAU,SAAS,EAAE,YAAY,EAAE;AACrD,kBAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;aAChE,CAAC;AACF,mBAAO,SAAS,CAAC;WAClB,MAAM;AACN,gBAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC1C,mBAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;WAC7B;SACF;;;;;;WAzCG,IAAI;;;AA4CV,MAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;AAgB3C,IAAE,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,GAAG,UAAS,SAAS,EAAE,OAAO,EAAE;;;AAG1D,QAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC1B,aAAO,IAAI,CAAC,MAAM,CAAC;KACpB;AACD,QAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AACtC,WAAO,IAAI,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;GACrC,CAAC;;;;AAIF,IAAE,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,GAAG,YAAW;AAC9C,WAAO,IAAI,CAAC,MAAM,CAAC;GACpB,CAAC;AACF,IAAE,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,GAAG,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;;;;;;;;;;;AAWnE,IAAE,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,GAAG,UAAS,OAAO,EAAE;AAChD,QAAI,KAAK,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;AAC5B,QAAI,SAAS,CAAC;;;AAGd,SAAK,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;AAClC,SAAK,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;;;AAG9B,QAAI,QAAQ,IAAI,OAAO,EAAE;AACxB,WAAK,SAAS,IAAI,OAAO,CAAC,MAAM,EAAE;AACjC,aAAK,CAAC,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;OAC/C;KACD;;;AAGD,QAAI,CAAC,EAAE,GAAG,YAAW;AAAE,aAAO,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;KAAE,CAAC;AAClE,QAAI,CAAC,GAAG,GAAG,YAAW;AAAE,aAAO,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;KAAE,CAAC;AACpE,QAAI,CAAC,IAAI,GAAG,YAAW;AAAE,aAAO,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;KAAE,CAAC;;AAEtE,WAAO,IAAI,CAAC;GACZ,CAAC;;AAEF,SAAO,IAAI,CAAC;CAEb,CAAC,CAAE","file":"koto.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.koto = factory()\n}(this, function () { 'use strict';\n\n  /**\n   * Simple Assertion function\n   * @param  {anything} test    Anything that will evaluate to true of false.\n   * @param  {string} message The error message to send if `test` is false\n   */\n  function kotoAssert(test, message) {\n    if (test) {\n      return;\n    }\n    throw new Error('[koto] ' + message);\n  }\n\n  class Chart {\n  \t/**\n  \t * Set up a chart instance.\n  \t *\n  \t * For charts that are defined as extensions of other charts using\n  \t * `Chart.extend`, each chart's `constructor` method will be invoked starting\n  \t * with the \"oldest\" ancestor.\n  \t */\n  \tconstructor(selection) {\n  \t\tthis.base = selection; // Container for chart @type {d3.selection}.\n      this.hasDrawn = false; // Has this chart been drawn at lease once?\n\n      // private\n  \t\tthis._layers = {};\n  \t\tthis._attached = {};\n  \t\tthis._events = {};\n  \t}\n\n  \t/**\n  \t * A \"hook\" method that you may define to modify input data before it is used\n  \t * to draw the chart's layers and attachments. This method will be used by all\n  \t * sub-classes.\n  \t *\n  \t * Note: you will most likely never call this method directly, but rather\n  \t * include it as part of a chart definition, and then rely on d3.chart to\n  \t * invoke it when you draw the chart with {@link Chart#draw}.\n  \t *\n  \t * @param {Array} data Input data provided to @link Chart#draw}.\n  \t * @returns {mixed} Data to be used in drawing the chart's layers and\n  \t *                  attachments.\n  \t */\n  \ttransform(data) { return data; }\n\n  \t/**\n  \t * A \"hook\" method that you may define to choose which mutation of the input\n  \t * data is sent to which of the attached charts (by name). This method will\n  \t * be used by all sub-classes. This only applies to charts that use the\n  \t * {@link Chart#attach} method.\n  \t *\n  \t * Note: you will most likely never call this method directly, but rather\n  \t * include it as part of a chart definition, and then rely on d3.chart to\n  \t * invoke it when you draw the chart with {@link Chart#draw}.\n  \t *\n  \t * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n  \t * @param {Array} data Input data provided to {@link Chart#draw}.\n  \t * @returns {mixed} Data to be used in drawing the chart's layers and\n  \t *                  attachments.\n  \t */\n  \tdemux(name, data) { return data; }\n\n  \t/**\n  \t * A \"hook\" method that will allow you to run some arbitrary code before\n  \t * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n  \t *\n  \t * Note: you will most likely never call this method directly, but rather\n  \t * include it as part of a chart definition, and then rely on d3.chart to\n  \t * invoke it when you draw the chart with {@link Chart#draw}.\n  \t *\n  \t * @param  {[type]} data [description]\n  \t * @return {[type]}      [description]\n  \t */\n  \tpreDraw() {}\n\n  \t/**\n  \t * A \"hook\" method that will allow you to run some arbitrary code after\n  \t * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n  \t *\n  \t * Note: you will most likely never call this method directly, but rather\n  \t * include it as part of a chart definition, and then rely on d3.chart to\n  \t * invoke it when you draw the chart with {@link Chart#draw}.\n  \t *\n  \t * @param  {[type]} data [description]\n  \t * @return {[type]}      [description]\n  \t */\n  \tpostDraw() {}\n\n  \t/**\n  \t * Remove a layer from the chart.\n  \t *\n  \t * @param {String} name The name of the layer to remove.\n  \t * @returns {Layer} The layer removed by this operation.\n  \t */\n  \tunlayer(name) {\n  \t\tvar layer = this.layer(name);\n\n  \t\tdelete this._layers[name];\n  \t\tdelete layer._chart;\n\n  \t\treturn layer;\n  \t}\n\n  \t/**\n  \t * Interact with the chart's {@link Layer|layers}.\n  \t *\n  \t * If only a `name` is provided, simply return the layer registered to that\n  \t * name (if any).\n  \t *\n  \t * If a `name` and `selection` are provided, treat the `selection` as a\n  \t * previously-created layer and attach it to the chart with the specified\n  \t * `name`.\n  \t *\n  \t * If all three arguments are specified, initialize a new {@link Layer} using\n  \t * the specified `selection` as a base passing along the specified `options`.\n  \t *\n  \t * The {@link Layer.draw} method of attached layers will be invoked\n  \t * whenever this chart's {@link Chart#draw} is invoked and will receive the\n  \t * data (optionally modified by the chart's {@link Chart#transform} method.\n  \t *\n  \t * @param {String} name Name of the layer to attach or retrieve.\n  \t * @param {d3.selection|Layer} [selection] The layer's base or a\n  \t *        previously-created {@link Layer}.\n  \t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n  \t *        constructor}\n  \t *\n  \t * @returns {Layer}\n  \t */\n  \tlayer(name, selection, options) {\n  \t\tvar layer;\n\n  \t\tif (arguments.length === 1) {\n  \t\t\treturn this._layers[name];\n  \t\t}\n\n  \t\t// we are reattaching a previous layer, which the\n  \t\t// selection argument is now set to.\n  \t\tif (arguments.length === 2) {\n\n  \t\t\tif (typeof selection.draw === 'function') {\n  \t\t\t\tselection._chart = this;\n  \t\t\t\tthis._layers[name] = selection;\n  \t\t\t\treturn this._layers[name];\n\n  \t\t\t} else {\n  \t\t\t\tkotoAssert(false, 'When reattaching a layer, the second argument '+\n  \t\t\t\t\t'must be a d3.chart layer');\n  \t\t\t}\n  \t\t}\n\n  \t\tlayer = selection.layer(options);\n\n  \t\tthis._layers[name] = layer;\n\n  \t\tselection._chart = this;\n\n  \t\treturn layer;\n  \t}\n\n  \t/**\n  \t * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n  \t * method will be invoked whenever the containing chart's `draw` method is\n  \t * invoked.\n  \t *\n  \t * @param {String} attachmentName Name of the attachment\n  \t * @param {Chart} [chart] koto to register as a mix in of this chart. When\n  \t *        unspecified, this method will return the attachment previously\n  \t *        registered with the specified `attachmentName` (if any).\n  \t *\n  \t * @returns {Chart} Reference to this chart (chainable).\n  \t */\n  \tattach(attachmentName, chart) {\n  \t\tif (arguments.length === 1) {\n  \t\t\treturn this._attached[attachmentName];\n  \t\t}\n\n  \t\tthis._attached[attachmentName] = chart;\n  \t\treturn chart;\n  \t}\n\n  \t/**\n  \t * Update the chart's representation in the DOM, drawing all of its layers and\n  \t * any \"attachment\" charts (as attached via {@link Chart#attach}).\n  \t *\n  \t * Note: The first time you call this method, the property `hasDrawn` will be\n  \t * set to true. This is helpful if you want to only run some code on the first\n  \t * time the chart is drawn.\n  \t *\n  \t * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n  \t *        this cart's {@link Layer|layers} (if any) and the {@link\n  \t *        Chart#draw|draw method} of this chart's attachments (if any).\n  \t */\n  \tdraw(rawData) {\n\n  \t\tvar layerName, attachmentName, attachmentData;\n\n  \t\tvar data = this.transform(rawData);\n\n      this.preDraw(data);\n\n  \t\tfor (layerName in this._layers) {\n  \t\t\tthis._layers[layerName].draw(data);\n  \t\t}\n\n  \t\tfor (attachmentName in this._attached) {\n  \t\t\tif (this.demux) {\n  \t\t\t\tattachmentData = this.demux(attachmentName, data);\n  \t\t\t} else {\n  \t\t\t\tattachmentData = data;\n  \t\t\t}\n  \t\t\tthis._attached[attachmentName].draw(attachmentData);\n  \t\t}\n\n      this.hasDrawn = true;\n\n      this.postDraw(data);\n  \t}\n\n  \t/**\n  \t * Function invoked with the context specified when the handler was bound (via\n  \t * {@link Chart#on} {@link Chart#once}).\n  \t *\n  \t * @callback ChartEventHandler\n  \t * @param {...*} arguments Invoked with the arguments passed to {@link\n  \t *         Chart#trigger}\n  \t */\n\n  \t/**\n  \t * Subscribe a callback function to an event triggered on the chart. See {@link\n  \t * Chart#once} to subscribe a callback function to an event for one occurence.\n  \t *\n  \t * @externalExample {runnable} chart-on\n  \t *\n  \t * @param {String} name Name of the event\n  \t * @param {ChartEventHandler} callback Function to be invoked when the event\n  \t *        occurs\n  \t * @param {Object} [context] Value to set as `this` when invoking the\n  \t *        `callback`. Defaults to the chart instance.\n  \t *\n  \t * @returns {Chart} A reference to this chart (chainable).\n  \t */\n  \ton(name, callback, context) {\n  \t\tvar events = this._events[name] || (this._events[name] = []);\n  \t\tevents.push({\n  \t\t\tcallback: callback,\n  \t\t\tcontext: context || this,\n  \t\t\t_chart: this\n  \t\t});\n  \t\treturn this;\n  \t}\n\n  \t/**\n  \t * Subscribe a callback function to an event triggered on the chart. This\n  \t * function will be invoked at the next occurance of the event and immediately\n  \t * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n  \t * event indefinitely.\n  \t *\n  \t * @externalExample {runnable} chart-once\n  \t *\n  \t * @param {String} name Name of the event\n  \t * @param {ChartEventHandler} callback Function to be invoked when the event\n  \t *        occurs\n  \t * @param {Object} [context] Value to set as `this` when invoking the\n  \t *        `callback`. Defaults to the chart instance\n  \t *\n  \t * @returns {Chart} A reference to this chart (chainable)\n  \t */\n  \tonce(name, callback, context) {\n  \t\tvar self = this;\n  \t\tvar once = function() {\n  \t\t\tself.off(name, once);\n  \t\t\tcallback.apply(this, arguments);\n  \t\t};\n  \t\treturn this.on(name, once, context);\n  \t}\n\n  \t/**\n  \t * Unsubscribe one or more callback functions from an event triggered on the\n  \t * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n  \t * When only a `name` is specified, all handlers subscribed to that event will\n  \t * be unsubscribed. When a `name` and `callback` are specified, only that\n  \t * function will be unsubscribed from that event. When a `name` and `context`\n  \t * are specified (but `callback` is omitted), all events bound to the given\n  \t * event with the given context will be unsubscribed.\n  \t *\n  \t * @externalExample {runnable} chart-off\n  \t *\n  \t * @param {String} [name] Name of the event to be unsubscribed\n  \t * @param {ChartEventHandler} [callback] Function to be unsubscribed\n  \t * @param {Object} [context] Contexts to be unsubscribe\n  \t *\n  \t * @returns {Chart} A reference to this chart (chainable).\n  \t */\n  \toff(name, callback, context) {\n  \t\tvar names, n, events, event, i, j;\n\n  \t\t// remove all events\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (name in this._events) {\n  \t\t\t\tthis._events[name].length = 0;\n  \t\t\t}\n  \t\t\treturn this;\n  \t\t}\n\n  \t\t// remove all events for a specific name\n  \t\tif (arguments.length === 1) {\n  \t\t\tevents = this._events[name];\n  \t\t\tif (events) {\n  \t\t\t\tevents.length = 0;\n  \t\t\t}\n  \t\t\treturn this;\n  \t\t}\n\n  \t\t// remove all events that match whatever combination of name, context\n  \t\t// and callback.\n  \t\tnames = name ? [name] : Object.keys(this._events);\n  \t\tfor (i = 0; i < names.length; i++) {\n  \t\t\tn = names[i];\n  \t\t\tevents = this._events[n];\n  \t\t\tj = events.length;\n  \t\t\twhile (j--) {\n  \t\t\t\tevent = events[j];\n  \t\t\t\tif ((callback && callback === event.callback) ||\n  \t\t\t\t\t\t(context && context === event.context)) {\n  \t\t\t\t\tevents.splice(j, 1);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn this;\n  \t}\n\n  \t/**\n  \t * Publish an event on this chart with the given `name`.\n  \t *\n  \t * @externalExample {runnable} chart-trigger\n  \t *\n  \t * @param {String} name Name of the event to publish\n  \t * @param {...*} arguments Values with which to invoke the registered\n  \t *        callbacks.\n  \t *\n  \t * @returns {Chart} A reference to this chart (chainable).\n  \t */\n  \ttrigger(name) {\n  \t\tvar args = Array.prototype.slice.call(arguments, 1);\n  \t\tvar events = this._events[name];\n  \t\tvar i, ev;\n\n  \t\tif (events !== undefined) {\n  \t\t\tfor (i = 0; i < events.length; i++) {\n  \t\t\t\tev = events[i];\n  \t\t\t\tev.callback.apply(ev.context, args);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn this;\n  \t}\n  }\n\n  var lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n  /**\n   * Loop through handers and call them on selection\n   * @param {d3.selection} selection The node to run the handler on.\n   *                                  it could be an `d3.transition` selection\n   * @param {lifecycle event} handlers A function to call for that layers named\n   *                           \t\t\t\t lifecycle event.\n   */\n  function selectionHandler (selection, handlers) {\n  \tvar idx, len;\n  \tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n  \t\t// Attach a reference to the parent chart so the selection's\n  \t\t// `chart` method will function correctly.\n  \t\tselection._chart = handlers[idx].chart || this._base._chart;\n  \t\tselection.call(handlers[idx].callback);\n  \t}\n  }\n\n  /**\n   * Create a layer using the provided `base`. The layer instance is *not*\n   * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n   * `base` selection it describes; users interact with the instance via these\n   * bound methods.\n   *\n   * @private\n   * @class\n   *\n   * @param {d3.selection} base The containing DOM node for the layer.\n   */\n  class Layer {\n  \tconstructor(base) {\n  \t\tthis._base = base;\n  \t\tthis._handlers = {};\n  \t}\n\n  \t/**\n  \t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n  \t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n  \t *\n  \t * @param {Array} data Value passed to {@link Layer#draw}\n  \t */\n  \tdataBind() {\n  \t\tkotoAssert(false, 'Layers must specify a dataBind method.');\n  \t}\n\n  \t/**\n  \t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n  \t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n  \t * Layer instances.\n  \t */\n  \tinsert() {\n  \t\tkotoAssert(false, 'Layers must specify an `insert` method.');\n  \t}\n\n  \t/**\n  \t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n  \t * events) are triggered when {@link Layer#draw} is invoked--see that method\n  \t * for more details on lifecycle events.\n  \t *\n  \t * @param {String} eventName Identifier for the lifecycle event for which to\n  \t *        subscribe.\n  \t * @param {Function} handler Callback function\n  \t *\n  \t * @returns {d3.selection} Reference to the layer's base.\n  \t */\n  \ton(eventName, handler, options) {\n  \t\toptions = options || {};\n\n  \t\tkotoAssert(lifecycleRe.test(eventName),\n  \t\t\t'Unrecognized lifecycle event name specified to `Layer#on`: \\'${eventName}\\'.');\n\n  \t\tif (!(eventName in this._handlers)) {\n  \t\t\tthis._handlers[eventName] = [];\n  \t\t}\n  \t\tthis._handlers[eventName].push({\n  \t\t\tcallback: handler,\n  \t\t\tchart: options.chart || null\n  \t\t});\n  \t\treturn this._base;\n  \t}\n\n  \t/**\n  \t * Unsubscribe the specified handler from the specified event. If no handler is\n  \t * supplied, remove *all* handlers from the event.\n  \t *\n  \t * @param {String} eventName Identifier for event from which to remove\n  \t *        unsubscribe\n  \t * @param {Function} handler Callback to remove from the specified event\n  \t *\n  \t * @returns {d3.selection} Reference to the layer's base.\n  \t */\n  \toff(eventName, handler) {\n\n  \t\tvar handlers = this._handlers[eventName];\n  \t\tvar idx;\n\n  \t\tkotoAssert(lifecycleRe.test(eventName),\n  \t\t\t'Unrecognized lifecycle event name specified to `Layer#on`: \\'${eventName}\\'.');\n\n  \t\tif (!handlers) {\n  \t\t\treturn this._base;\n  \t\t}\n\n  \t\tif (arguments.length === 1) {\n  \t\t\thandlers.length = 0;\n  \t\t\treturn this._base;\n  \t\t}\n\n  \t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n  \t\t\tif (handlers[idx].callback === handler) {\n  \t\t\t\thandlers.splice(idx, 1);\n  \t\t\t}\n  \t\t}\n  \t\treturn this._base;\n  \t}\n\n  \t/**\n  \t * Render the layer according to the input data: Bind the data to the layer\n  \t * (according to {@link Layer#dataBind}, insert new elements (according to\n  \t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n  \t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n  \t *\n  \t * - update\n  \t * - update:transition\n  \t * - enter\n  \t * - enter:transition\n  \t * - exit\n  \t * - exit:transition\n  \t *\n  \t * @param {Array} data Data to drive the rendering.\n  \t */\n  \tdraw(data) {\n  \t\tvar bound,\n  \t\t\tentering,\n  \t\t\tevents,\n  \t\t\tselection,\n  \t\t\tmethod,\n  \t\t\thandlers,\n  \t\t\ttransitionHandlers,\n  \t\t\teventName;\n\n  \t\tbound = this.dataBind.call(this._base, data);\n\n  \t\tkotoAssert(bound instanceof d3.selection,\n  \t\t  'Invalid selection defined by `Layer#dataBind` method.');\n  \t\tkotoAssert(bound.enter, 'Layer selection not properly bound.');\n\n  \t\tentering = bound.enter();\n  \t\tentering._chart = this._base._chart;\n\n  \t\tevents = [\n  \t\t\t{\n  \t\t\t\tname: 'update',\n  \t\t\t\tselection: bound\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: 'enter',\n  \t\t\t\tselection: entering,\n  \t\t\t\tmethod: this.insert\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: 'merge',\n  \t\t\t\t// Although the `merge` lifecycle event shares its selection object\n  \t\t\t\t// with the `update` lifecycle event, the object's contents will be\n  \t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n  \t\t\t\t// when triggering the `enter` event.\n  \t\t\t\tselection: bound\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: 'exit',\n  \t\t\t\t// Although the `exit` lifecycle event shares its selection object\n  \t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n  \t\t\t\t// contents will be modified when d3.chart invokes\n  \t\t\t\t// `d3.selection.exit`.\n  \t\t\t\tselection: bound,\n  \t\t\t\tmethod: bound.exit\n  \t\t\t}\n  \t\t];\n\n  \t\tfor (var i = 0, l = events.length; i < l; ++i) {\n  \t\t\teventName = events[i].name;\n  \t\t\tselection = events[i].selection;\n  \t\t\tmethod = events[i].method;\n\n  \t\t\t// Some lifecycle selections modify shared state, so they must be\n  \t\t\t// deferred until just prior to handler invocation.\n  \t\t\tif (typeof method === 'function') {\n  \t\t\t\tselection = method.call(selection);\n  \t\t\t}\n\n  \t\t\tif (selection.empty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n\n  \t\t\t// Although `selection instanceof d3.selection` is more explicit,\n  \t\t\t// it fails in IE8, so we use duck typing to maintain\n  \t\t\t// compatability.\n\n  \t\t\tkotoAssert(selection && selection instanceof d3.selection,\n  \t\t\t  'Invalid selection defined for ${eventName} lifecycle event.');\n\n  \t\t\thandlers = this._handlers[eventName];\n\n  \t\t\tif (handlers) {\n  \t\t\t\tselectionHandler.call(this, selection, handlers);\n  \t\t\t}\n\n  \t\t\ttransitionHandlers = this._handlers[eventName + ':transition'];\n\n  \t\t\tif (handlers && handlers.length) {\n  \t\t\t\tselection = selection.transition();\n  \t\t\t\tselectionHandler.call(this, selection, transitionHandlers);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  class Options {\n  \tconstructor(...options) {\n  \t\tvar i, key;\n  \t\tthis._options = options[0];\n\n  \t\tfor (i=1; i<options.length; i++) {\n  \t\t\tfor(key in options[i]) {\n  \t\t\t\tthis._options[key] = options[i][key];\n  \t\t\t}\n  \t\t}\n\n  \t}\n  \t/**\n  \t * Get option with given name.\n  \t * @param  {string} name the name of the option.\n  \t * @return {Object}      The option definition of the option with given name.\n  \t */\n  \tget(name) {\n  \t\tkotoAssert(this._options[name], 'no option with that name');\n  \t\treturn this._options[name];\n  \t}\n\n  \t/**\n  \t * Set create of set option defintion with geven name (or key).\n  \t * @param {mixed} nameOrObject This can either be an object with key of option name(s)\n  \t *                             or, it can be a string with the option name.\n  \t * @param {Object} object      The option definition. Only used if used a named string\n  \t *                             as the first argument.\n  \t */\n  \tset(nameOrObject, object) {\n  \t\tvar key;\n  \t\tif (arguments.length === 1) {\n  \t\t\tfor (key in nameOrObject) {\n  \t\t\t\tkotoAssert(this._options[key], 'no option with that name');\n  \t\t\t\tthis._options[key] = nameOrObject[key];\n  \t\t\t}\n  \t\t} else {\n  \t\t\tkotoAssert(this._options[nameOrObject], 'no option with that name');\n  \t\t\tthis._options[nameOrObject] = object[key];\n  \t\t}\n  \t\treturn this;\n  \t}\n\n  \t/**\n  \t * Remove an option item. This is helpful if you are inheriting from a chart\n  \t * and want to remove configurable options that have been inherited.\n  \t * @param  {string} name The name of the option definition you want to remove.\n  \t * @return {option}      Instance of {@link Option} (chainable).\n  \t */\n  \tremove(name){\n  \t\tdelete this._options[name];\n  \t\treturn this;\n  \t}\n  }\n\n  kotoAssert(d3, 'd3.js is required');\n\n  /**\n   * Registry {@link Chart} defintions to be used later.\n   * @class\n   *\n   * @param {Class} Options The Options class.\n   * @param {Class} Layer The Layer class.\n   * @param {Class} Chart The Chart class.\n   */\n  class Koto {\n    constructor(Options, Layer, Chart) {\n      this._registry = {};\n\n      this.Options = Options;\n      this.Layer = Layer;\n      this.Chart = Chart;\n    }\n\n    /**\n     * Takes a name and a function that returns a chart definiion (class).\n     * It registeres that chart defintion with given name and makes it available\n     * to the `d3.seletion.chart` method.\n     *\n     * If function is called with no parameters, the list of registered charts is\n     * returned.\n     *\n     * If the function is only called with 'name' parameter, the chart definition\n     * registered with that name is returned.\n     *\n     * If the function is called with 'name' and 'classFn' parameter, the chart\n     * definition is registered (or overwritten) with the given name.\n     *\n     * @param  {string} name Name of chart to get or register.\n     * @param  {function} classFn A function that returns a chart.\n     * @return {Chart} The chart registered with given name (if any).\n     */\n    chart(name, classFn) {\n      var baseChart;\n      if (arguments.length === 0) {\n        return this._registry;\n      } else if (arguments.length === 1) {\n        baseChart = this._registry[name];\n        baseChart.extends = function (childName, childClassFn) {\n          this._registry[childName] = childClassFn(this._registry[name]);\n        };\n        return baseChart;\n      } else {\n      \tthis._registry[name] = classFn(this.Chart);\n        return this._registry[name];\n      }\n    }\n  }\n\n  var koto = new Koto(Options, Layer, Chart);\n\n  /**\n   * d3.js extensions\n   */\n\n  /**\n   * Instantiate a chart or return the chart that the current selection belongs\n   * to.\n   *\n   * @param {String} [chartName] The name of the chart to instantiate. If the\n   *        name is unspecified, this method will return the chart that the\n   *        current selection belongs to.\n   * @param {mixed} options The options to use when instantiated the new chart.\n   *        See {@link Chart} for more information.\n   */\n  d3.selection.prototype.chart = function(chartName, options) {\n  \t// Without an argument, attempt to resolve the current selection's\n  \t// containing d3.chart.\n    if (arguments.length === 0) {\n      return this._chart;\n    }\n    var ChartCtor = koto.chart(chartName);\n    return new ChartCtor(this, options);\n  };\n\n  // Implement the zero-argument signature of `d3.selection.prototype.chart`\n  // for all selection types.\n  d3.selection.enter.prototype.chart = function() {\n    return this._chart;\n  };\n  d3.transition.prototype.chart = d3.selection.enter.prototype.chart;\n\n  /**\n   * Create a new layer on the d3 selection from which it is called.\n   *\n   * @static\n   *\n   * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n   *        constructor}\n   * @returns {d3.selection}\n   */\n  d3.selection.prototype.layer = function(options) {\n  \tvar layer = new Layer(this);\n  \tvar eventName;\n\n  \t// Set layer methods (required)\n  \tlayer.dataBind = options.dataBind;\n  \tlayer.insert = options.insert;\n\n  \t// Bind events (optional)\n  \tif ('events' in options) {\n  \t\tfor (eventName in options.events) {\n  \t\t\tlayer.on(eventName, options.events[eventName]);\n  \t\t}\n  \t}\n\n  \t// Mix the public methods into the D3.js selection (bound appropriately)\n  \tthis.on = function() { return layer.on.apply(layer, arguments); };\n  \tthis.off = function() { return layer.off.apply(layer, arguments); };\n  \tthis.draw = function() { return layer.draw.apply(layer, arguments); };\n\n  \treturn this;\n  };\n\n  return koto;\n\n}));\n"],"sourceRoot":"/source/"}