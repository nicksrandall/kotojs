{"version":3,"sources":["koto.js"],"names":[],"mappings":"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","file":"koto.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.koto = factory()\n}(this, function () { 'use strict';\n\n\t/**\n\t * Simple Assertion function\n\t * @param  {anything} test    Anything that will evaluate to true of false.\n\t * @param  {string} message The error message to send if `test` is false\n\t */\n\tfunction kotoAssert(test, message) {\n\t  if (test) {\n\t    return;\n\t  }\n\t  throw new Error('[koto] ' + message);\n\t}\n\n\tclass Chart {\n\t  constructor(selection) {\n\t    this.base = selection; // Container for chart @type {d3.selection}.\n\t      this.hasDrawn = false; // Has this chart been drawn at lease once?\n\n\t      // private\n\t      this._layers = {};\n\t      this._attached = {};\n\t      this._events = {};\n\t      this._configs = {};\n\t      this._accessors = {};\n\t  }\n\n\t  /**\n\t   * A \"hook\" method that you may define to modify input data before it is used\n\t   * to draw the chart's layers and attachments. This method will be used by all\n\t   * sub-classes.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {Array} data Input data provided to @link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  transform(data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that you may define to choose which mutation of the input\n\t   * data is sent to which of the attached charts (by name). This method will\n\t   * be used by all sub-classes. This only applies to charts that use the\n\t   * {@link Chart#attach} method.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param {String} data Name of attached chart defined in {@link Chart#attach}.\n\t   * @param {Array} data Input data provided to {@link Chart#draw}.\n\t   * @returns {mixed} Data to be used in drawing the chart's layers and\n\t   *                  attachments.\n\t   */\n\t  demux(name, data) { return data; }\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code before\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  preDraw() {}\n\n\t  /**\n\t   * A \"hook\" method that will allow you to run some arbitrary code after\n\t   * {@link Chart#draw}. This will run everytime {@link Chart#draw} is called.\n\t   *\n\t   * Note: you will most likely never call this method directly, but rather\n\t   * include it as part of a chart definition, and then rely on d3.chart to\n\t   * invoke it when you draw the chart with {@link Chart#draw}.\n\t   *\n\t   * @param  {[type]} data [description]\n\t   * @return {[type]}      [description]\n\t   */\n\t  postDraw() {}\n\n\t  /**\n\t   * Remove a layer from the chart.\n\t   *\n\t   * @param {String} name The name of the layer to remove.\n\t   * @returns {Layer} The layer removed by this operation.\n\t   */\n\t  unlayer(name) {\n\t    var layer = this.layer(name);\n\n\t    delete this._layers[name];\n\t    delete layer._chart;\n\n\t    return layer;\n\t  }\n\n\t  /**\n\t   * Interact with the chart's {@link Layer|layers}.\n\t   *\n\t   * If only a `name` is provided, simply return the layer registered to that\n\t   * name (if any).\n\t   *\n\t   * If a `name` and `selection` are provided, treat the `selection` as a\n\t   * previously-created layer and attach it to the chart with the specified\n\t   * `name`.\n\t   *\n\t   * If all three arguments are specified, initialize a new {@link Layer} using\n\t   * the specified `selection` as a base passing along the specified `options`.\n\t   *\n\t   * The {@link Layer.draw} method of attached layers will be invoked\n\t   * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t   * data (optionally modified by the chart's {@link Chart#transform} method.\n\t   *\n\t   * @param {String} name Name of the layer to attach or retrieve.\n\t   * @param {d3.selection|Layer} [selection] The layer's base or a\n\t   *        previously-created {@link Layer}.\n\t   * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t   *        constructor}\n\t   *\n\t   * @returns {Layer}\n\t   */\n\t  layer(name, selection, options) {\n\t    var _layer;\n\n\t    if (arguments.length === 1) {\n\t      return this._layers[name];\n\t    }\n\n\t    // we are reattaching a previous layer, which the\n\t    // selection argument is now set to.\n\t    if (arguments.length === 2) {\n\n\t      if (typeof selection.draw === 'function') {\n\t        selection._chart = this;\n\t        this._layers[name] = selection;\n\t        return this._layers[name];\n\n\t      } else {\n\t        kotoAssert(false, 'When reattaching a layer, the second argument '+\n\t          'must be a d3.chart layer');\n\t      }\n\t    }\n\n\t    _layer = selection.layer(options);\n\n\t    this._layers[name] = _layer;\n\n\t    selection._chart = this;\n\n\t    return _layer;\n\t  }\n\n\t  /**\n\t   * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t   * method will be invoked whenever the containing chart's `draw` method is\n\t   * invoked.\n\t   *\n\t   * @param {String} attachmentName Name of the attachment\n\t   * @param {Chart} [chart] koto to register as a mix in of this chart. When\n\t   *        unspecified, this method will return the attachment previously\n\t   *        registered with the specified `attachmentName` (if any).\n\t   *\n\t   * @returns {Chart} Reference to this chart (chainable).\n\t   */\n\t  attach(attachmentName, chart) {\n\t    if (arguments.length === 1) {\n\t      return this._attached[attachmentName];\n\t    }\n\n\t    this._attached[attachmentName] = chart;\n\t    return chart;\n\t  }\n\n\t  /**\n\t   * Update the chart's representation in the DOM, drawing all of its layers and\n\t   * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t   *\n\t   * Note: The first time you call this method, the property `hasDrawn` will be\n\t   * set to true. This is helpful if you want to only run some code on the first\n\t   * time the chart is drawn.\n\t   *\n\t   * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t   *        this cart's {@link Layer|layers} (if any) and the {@link\n\t   *        Chart#draw|draw method} of this chart's attachments (if any).\n\t   */\n\t  draw(rawData) {\n\n\t    var layerName, attachmentName, attachmentData;\n\n\t    var data = this.transform(rawData);\n\n\t    this.preDraw(data);\n\n\t    for (layerName in this._layers) {\n\t      this._layers[layerName].draw(data);\n\t    }\n\n\t    for (attachmentName in this._attached) {\n\t      if (this.demux) {\n\t        attachmentData = this.demux(attachmentName, data);\n\t      } else {\n\t        attachmentData = data;\n\t      }\n\t      this._attached[attachmentName].draw(attachmentData);\n\t    }\n\n\t    this.hasDrawn = true;\n\n\t    this.postDraw(data);\n\t  }\n\n\t  /**\n\t   * Function invoked with the context specified when the handler was bound (via\n\t   * {@link Chart#on} {@link Chart#once}).\n\t   *\n\t   * @callback ChartEventHandler\n\t   * @param {...*} arguments Invoked with the arguments passed to {@link\n\t   *         Chart#trigger}\n\t   */\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. See {@link\n\t   * Chart#once} to subscribe a callback function to an event for one occurence.\n\t   *\n\t   * @externalExample {runnable} chart-on\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  on(name, callback, context) {\n\t    var events = this._events[name] || (this._events[name] = []);\n\t    events.push({\n\t      callback: callback,\n\t      context: context || this,\n\t      _chart: this\n\t    });\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Subscribe a callback function to an event triggered on the chart. This\n\t   * function will be invoked at the next occurance of the event and immediately\n\t   * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t   * event indefinitely.\n\t   *\n\t   * @externalExample {runnable} chart-once\n\t   *\n\t   * @param {String} name Name of the event\n\t   * @param {ChartEventHandler} callback Function to be invoked when the event\n\t   *        occurs\n\t   * @param {Object} [context] Value to set as `this` when invoking the\n\t   *        `callback`. Defaults to the chart instance\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable)\n\t   */\n\t  once(name, callback, context) {\n\t    var self = this;\n\t    var _once = function() {\n\t      self.off(name, _once);\n\t      callback.apply(this, arguments);\n\t    };\n\t    return this.on(name, _once, context);\n\t  }\n\n\t  /**\n\t   * Unsubscribe one or more callback functions from an event triggered on the\n\t   * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t   * When only a `name` is specified, all handlers subscribed to that event will\n\t   * be unsubscribed. When a `name` and `callback` are specified, only that\n\t   * function will be unsubscribed from that event. When a `name` and `context`\n\t   * are specified (but `callback` is omitted), all events bound to the given\n\t   * event with the given context will be unsubscribed.\n\t   *\n\t   * @externalExample {runnable} chart-off\n\t   *\n\t   * @param {String} [name] Name of the event to be unsubscribed\n\t   * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t   * @param {Object} [context] Contexts to be unsubscribe\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  off(name, callback, context) {\n\t    var names, n, events, event, i, j;\n\n\t    // remove all events\n\t    if (arguments.length === 0) {\n\t      for (name in this._events) {\n\t        this._events[name].length = 0;\n\t      }\n\t      return this;\n\t    }\n\n\t    // remove all events for a specific name\n\t    if (arguments.length === 1) {\n\t      events = this._events[name];\n\t      if (events) {\n\t        events.length = 0;\n\t      }\n\t      return this;\n\t    }\n\n\t    // remove all events that match whatever combination of name, context\n\t    // and callback.\n\t    names = name ? [name] : Object.keys(this._events);\n\t    for (i = 0; i < names.length; i++) {\n\t      n = names[i];\n\t      events = this._events[n];\n\t      j = events.length;\n\t      while (j--) {\n\t        event = events[j];\n\t        if ((callback && callback === event.callback) ||\n\t            (context && context === event.context)) {\n\t          events.splice(j, 1);\n\t        }\n\t      }\n\t    }\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Publish an event on this chart with the given `name`.\n\t   *\n\t   * @externalExample {runnable} chart-trigger\n\t   *\n\t   * @param {String} name Name of the event to publish\n\t   * @param {...*} arguments Values with which to invoke the registered\n\t   *        callbacks.\n\t   *\n\t   * @returns {Chart} A reference to this chart (chainable).\n\t   */\n\t  trigger(name) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    var events = this._events[name];\n\t    var i, ev;\n\n\t    if (events !== undefined) {\n\t      for (i = 0; i < events.length; i++) {\n\t        ev = events[i];\n\t        ev.callback.apply(ev.context, args);\n\t      }\n\t    }\n\n\t    return this;\n\t  }\n\t  /**\n\t   * Get and set chart options (or configs)\n\t   *\n\t   * @param  {mixed} nameOrObject name of item getting or setting\n\t   *                              or its an object with key value pairs.\n\t   * @param  {mixed} value the value for config item witha that name.\n\t   * @return {mixed} if getting, its the value. if setting it is the chart instance.\n\t   */\n\t  config(nameOrObject, value) {\n\t    var key;\n\t    if (arguments.length === 0) {\n\t      return this._configs;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof nameOrObject === 'object') {\n\t        for (key in nameOrObject) {\n\t          this._configs[key] = nameOrObject[key];\n\t        }\n\t        return this;\n\t      }\n\t      kotoAssert(this._configs[nameOrObject], `${nameOrObject} is not a valid option.`);\n\t      return this._configs[nameOrObject];\n\t    }\n\n\t    if(arguments.length === 2) {\n\t      this._configs[nameOrObject] = value;\n\t      return this;\n\t    }\n\t  }\n\n\t  /**\n\t   * This will get or set any of the chart's accessors.\n\t   *\n\t   * @param  {String or Object} item If string, it will return the function for that accessor item.\n\t   *                                 If object, it will update that accessor with set function.\n\t   * @param  {function} [value] The function to update accessor item with.\n\t   * @return {object} The chart to preserve chainability.\n\t   */\n\t  accessor (item, value) {\n\t    var key;\n\t    if (arguments.length === 0) {\n\t      return this._accessors;\n\t    }\n\n\t    if (arguments.length === 1) {\n\t      if (typeof item === 'string') {\n\t        kotoAssert(this._accessors[item], `${item} is not a valid accessor.`);\n\t        if (typeof this._accessors[item] === 'object') {\n\t          return this._accessors[item].accessor;\n\t        }\n\t        return this._accessors[item];\n\t      } else {\n\t        for (key in item) {\n\t          this._accessors[key] = item[key];\n\t        }\n\t      }\n\t    } else {\n\t      this._accessors[item] = value;\n\t    }\n\t    return this;\n\t  }\n\t}\n\n\tvar lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n\t/**\n\t * Create a layer using the provided `base`. The layer instance is *not*\n\t * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n\t * `base` selection it describes; users interact with the instance via these\n\t * bound methods.\n\t *\n\t * @private\n\t * @class\n\t *\n\t * @param {d3.selection} base The containing DOM node for the layer.\n\t */\n\tclass Layer {\n\t\tconstructor(base) {\n\t\t\tthis._base = base;\n\t\t\tthis._handlers = {};\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t\t *\n\t\t * @param {Array} data Value passed to {@link Layer#draw}\n\t\t */\n\t\tdataBind() {\n\t\t\tkotoAssert(false, 'Layers must specify a dataBind method.');\n\t\t}\n\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t\t * Layer instances.\n\t\t */\n\t\tinsert() {\n\t\t\tkotoAssert(false, 'Layers must specify an `insert` method.');\n\t\t}\n\n\t\t/**\n\t\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t\t * for more details on lifecycle events.\n\t\t *\n\t\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t\t *        subscribe.\n\t\t * @param {Function} handler Callback function\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\ton(eventName, handler, options) {\n\t\t\toptions = options || {};\n\n\t\t\tkotoAssert(lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!(eventName in this._handlers)) {\n\t\t\t\tthis._handlers[eventName] = [];\n\t\t\t}\n\t\t\tthis._handlers[eventName].push({\n\t\t\t\tcallback: handler,\n\t\t\t\tchart: options.chart || null\n\t\t\t});\n\t\t\treturn this._base;\n\t\t}\n\n\t\t/**\n\t\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t\t * supplied, remove *all* handlers from the event.\n\t\t *\n\t\t * @param {String} eventName Identifier for event from which to remove\n\t\t *        unsubscribe\n\t\t * @param {Function} handler Callback to remove from the specified event\n\t\t *\n\t\t * @returns {Chart} Reference to the layer instance (chaining).\n\t\t */\n\t\toff(eventName, handler) {\n\n\t\t\tvar handlers = this._handlers[eventName];\n\t\t\tvar idx;\n\n\t\t\tkotoAssert(lifecycleRe.test(eventName),\n\t\t\t\t`Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n\t\t\tif (!handlers) {\n\t\t\t\treturn this._base;\n\t\t\t}\n\n\t\t\tif (arguments.length === 1) {\n\t\t\t\thandlers.length = 0;\n\t\t\t\treturn this._base;\n\t\t\t}\n\n\t\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\t\thandlers.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._base;\n\t\t}\n\n\t\t/**\n\t\t * Render the layer according to the input data: Bind the data to the layer\n\t\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t\t *\n\t\t * - update\n\t\t * - update:transition\n\t\t * - enter\n\t\t * - enter:transition\n\t\t * - exit\n\t\t * - exit:transition\n\t\t *\n\t\t * @param {Array} data Data to drive the rendering.\n\t\t */\n\t\tdraw(data) {\n\t\t\tvar bound,\n\t\t\t\tentering,\n\t\t\t\tevents,\n\t\t\t\tselection,\n\t\t\t\tmethod,\n\t\t\t\thandlers,\n\t\t\t\teventName,\n\t      idx,\n\t      len,\n\t      tidx,\n\t      tlen;\n\n\t\t\tbound = this.dataBind.call(this._base, data);\n\n\t\t\tkotoAssert(bound instanceof d3.selection,\n\t      'Invalid selection defined by `Layer#dataBind` method.');\n\t\t\tkotoAssert(bound.enter, 'Layer selection not properly bound.');\n\n\t\t\tentering = bound.enter();\n\t\t\tentering._chart = this._base._chart;\n\n\t\t\tevents = [\n\t\t\t\t{\n\t\t\t\t\tname: 'update',\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'enter',\n\t\t\t\t\tselection: entering,\n\t\t\t\t\tmethod: this.insert\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'merge',\n\t\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t\t// when triggering the `enter` event.\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'exit',\n\t\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t\t// `d3.selection.exit`.\n\t\t\t\t\tselection: bound,\n\t\t\t\t\tmethod: bound.exit\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\t\teventName = events[i].name;\n\t\t\t\tselection = events[i].selection;\n\t\t\t\tmethod = events[i].method;\n\n\t\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t\t// deferred until just prior to handler invocation.\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tselection = method.call(selection);\n\t\t\t\t}\n\n\t\t\t\tif (selection.empty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t\t// compatability.\n\n\t\t\t\tkotoAssert(selection && selection instanceof d3.selection,\n\t        `Invalid selection defined for ${eventName} lifecycle event.`);\n\n\t\t\t\thandlers = this._handlers[eventName];\n\n\t      if (handlers) {\n\t        for (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t          // Attach a reference to the parent chart so the selection\"s\n\t          // `chart` method will function correctly.\n\t          selection._chart = handlers[idx].chart || this._base._chart;\n\t          selection.call(handlers[idx].callback);\n\t        }\n\t      }\n\n\t      handlers = this._handlers[eventName + ':transition'];\n\n\t      if (handlers && handlers.length) {\n\t        selection = selection.transition();\n\t        for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n\t          selection._chart = handlers[tidx].chart || this._base._chart;\n\t          selection.call(handlers[tidx].callback);\n\t        }\n\t      }\n\t\t\t}\n\t\t}\n\t}\n\n\tkotoAssert(d3, 'd3.js is required');\n\n\t/**\n\t * Registry {@link Chart} defintions to be used later.\n\t * @class\n\t *\n\t * @param {Class} Options The Options class.\n\t * @param {Class} Layer The Layer class.\n\t * @param {Class} Chart The Chart class.\n\t */\n\tclass Koto {\n\t  constructor(Layer, Chart) {\n\t    this._registry = {};\n\n\t    this.Layer = Layer;\n\t    this.Chart = Chart;\n\t  }\n\n\t  /**\n\t   * Takes a name and a function that returns a chart definiion (class).\n\t   * It registeres that chart defintion with given name and makes it available\n\t   * to the `d3.seletion.chart` method.\n\t   *\n\t   * If function is called with no parameters, the list of registered charts is\n\t   * returned.\n\t   *\n\t   * If the function is only called with 'name' parameter, the chart definition\n\t   * registered with that name is returned.\n\t   *\n\t   * If the function is called with 'name' and 'classFn' parameter, the chart\n\t   * definition is registered (or overwritten) with the given name.\n\t   *\n\t   * @param  {string} name Name of chart to get or register.\n\t   * @param  {function} classFn A function that returns a chart.\n\t   * @return {Chart} The chart registered with given name (if any).\n\t   */\n\t  chart(name, classFn) {\n\t    var baseChart, _Koto = this;\n\t    if (arguments.length === 0) {\n\t      return this._registry;\n\t    } else if (arguments.length === 1) {\n\t      kotoAssert(this._registry[name], `no chart registered with name ${name}`);\n\t      baseChart = this._registry[name];\n\t      baseChart.extend = function (childName, childClassFn) {\n\t        _Koto._registry[childName] = childClassFn(baseChart);\n\t        return _Koto._registry[childName];\n\t      };\n\t      return baseChart;\n\t    } else {\n\t      this._registry[name] = classFn(this.Chart);\n\t      return this._registry[name];\n\t    }\n\t  }\n\t}\n\n\tvar koto = new Koto(Layer, Chart);\n\n\t/**\n\t * d3.js extensions\n\t */\n\n\t/**\n\t * Instantiate a chart or return the chart that the current selection belongs\n\t * to.\n\t *\n\t * @param {String} [chartName] The name of the chart to instantiate. If the\n\t *        name is unspecified, this method will return the chart that the\n\t *        current selection belongs to.\n\t * @param {mixed} options The options to use when instantiated the new chart.\n\t *        See {@link Chart} for more information.\n\t */\n\td3.selection.prototype.chart = function(chartName) {\n\t\t// Without an argument, attempt to resolve the current selection's\n\t\t// containing d3.chart.\n\t  if (arguments.length === 0) {\n\t    return this._chart;\n\t  }\n\t  var ChartCtor = koto.chart(chartName);\n\t  return new ChartCtor(this);\n\t};\n\n\t// Implement the zero-argument signature of `d3.selection.prototype.chart`\n\t// for all selection types.\n\td3.selection.enter.prototype.chart = function() {\n\t  return this._chart;\n\t};\n\td3.transition.prototype.chart = d3.selection.enter.prototype.chart;\n\n\t/**\n\t * Create a new layer on the d3 selection from which it is called.\n\t *\n\t * @static\n\t *\n\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t *        constructor}\n\t * @returns {d3.selection}\n\t */\n\td3.selection.prototype.layer = function(options) {\n\t\tvar layer = new Layer(this);\n\t\tvar eventName;\n\n\t\t// Set layer methods (required)\n\t\tlayer.dataBind = options.dataBind;\n\t\tlayer.insert = options.insert;\n\n\t\t// Bind events (optional)\n\t\tif ('events' in options) {\n\t\t\tfor (eventName in options.events) {\n\t\t\t\tlayer.on(eventName, options.events[eventName]);\n\t\t\t}\n\t\t}\n\n\t\t// Mix the public methods into the D3.js selection (bound appropriately)\n\t\tthis.on = function() { return layer.on.apply(layer, arguments); };\n\t\tthis.off = function() { return layer.off.apply(layer, arguments); };\n\t\tthis.draw = function() { return layer.draw.apply(layer, arguments); };\n\n\t\treturn this;\n\t};\n\n\treturn koto;\n\n}));\n"],"sourceRoot":"/source/"}